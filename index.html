<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta
            http-equiv="Cache-Control"
            content="no-cache, no-store, must-revalidate"
        />
        <meta http-equiv="Pragma" content="no-cache" />
        <meta http-equiv="Expires" content="0" />
        <title>Hamina Clipboard Tools</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
        <link
            href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css"
            rel="stylesheet"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;600;700&display=swap"
            rel="stylesheet"
        />
        <style>
            :root {
                --background: #f0f0f0;
                --foreground: #e0e0e0;
                --text: #333;
                --header: #666;
                --panel-bg: #ffffff;
                --button-bg: #4285f4;
                --button-hover: #3b78e7;
                --button-text: #ffffff;
            }

            body {
                margin: 0;
                padding: 0;
                display: flex;
                font-family: "Quicksand", sans-serif;
                background-color: var(--background);
                color: var(--text);
            }

            #canvas {
                flex-grow: 1;
            }

            /* Left toolbar - tool selection */
            .tool-menu {
                position: fixed;
                top: 20px;
                left: 20px;
                display: flex;
                flex-direction: column;
                gap: 10px;
                z-index: 3;
                padding-left: env(safe-area-inset-left);
                padding-bottom: env(safe-area-inset-bottom);
            }

            .tool-button {
                width: 40px;
                height: 40px;
                border-radius: 6px;
                border: none;
                background-color: var(--panel-bg);
                cursor: pointer;
                font-size: 24px;
                color: var(--text);
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0px 4px 4px 4px rgba(0, 0, 0, 0.025);
                transition: background-color 0.1s;
                -webkit-appearance: none;
                touch-action: manipulation;
                padding: 0;
            }

            .tool-button:hover {
                background-color: var(--foreground);
            }

            .tool-button:active {
                transform: translateY(3px);
                box-shadow: 0px 4px 4px 4px rgba(0, 0, 0, 0.025);
            }

            .tool-button.active {
                background-color: var(--button-bg);
                color: var(--button-text);
            }

            .kbd {
                display: inline-block;
                padding: 3px 5px;
                font:
                    11px/1 "SFMono-Regular",
                    Consolas,
                    "Liberation Mono",
                    Menlo,
                    Courier,
                    monospace;
                color: #444d56;
                vertical-align: middle;
                background-color: #fafbfc;
                border: solid 1px #d1d5da;
                border-bottom-color: #c6cbd1;
                border-radius: 3px;
                box-shadow: inset 0 -1px 0 #c6cbd1;
            }

            .controls-list {
                margin: 0;
                padding-left: 20px;
                font-size: 14px;
            }

            .controls-list li {
                margin-bottom: 8px;
            }

            /* Right panel - tool options */
            .toolbar {
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px;
                background-color: var(--panel-bg);
                border-radius: 6px;
                border: none;
                box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
                display: none;
                flex-direction: column;
                gap: 15px;
                z-index: 3;
                width: 280px;
                max-height: calc(100vh - 60px);
                overflow-y: auto;
                box-sizing: border-box;
            }

            .toolbar.visible {
                display: flex;
            }

            .toolbar-description {
                margin: 0;
                font-size: 14px;
                color: var(--text);
            }

            .type-options {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .type-option {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 8px;
                border-radius: 6px;
                cursor: pointer;
                transition: background-color 0.1s;
            }

            .type-option:hover {
                background-color: var(--foreground);
            }

            .type-option input[type="radio"],
            .type-option input[type="checkbox"] {
                width: auto;
                margin: 0;
            }

            h3 {
                margin: 0;
                font-size: 14px;
                color: var(--header);
                font-weight: 700;
            }

            select,
            input,
            textarea {
                width: 100%;
                padding: 8px;
                border: 1px solid var(--foreground);
                border-radius: 6px;
                font-size: 14px;
                font-family: inherit;
                background-color: var(--background);
                color: var(--text);
                box-sizing: border-box;
            }

            textarea {
                height: 200px;
                font-size: 10px;
                resize: vertical;
            }

            .input-group {
                display: flex;
                gap: 10px;
            }

            .input-group > * {
                flex: 1;
            }

            .rotation-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .toolbar-button {
                width: 100%;
                padding: 8px;
                border-radius: 6px;
                border: none;
                background-color: var(--panel-bg);
                cursor: pointer;
                font-size: 14px;
                font-family: inherit;
                color: var(--text);
                transition: background-color 0.1s;
                -webkit-appearance: none;
                touch-action: manipulation;
                box-shadow: 0px 1px 3px rgba(0, 0, 0, 0.1);
            }

            .toolbar-button:hover {
                background-color: var(--foreground);
            }

            .toolbar-button:active {
                transform: translateY(2px);
            }

            .toolbar-button.blue {
                background-color: var(--button-bg);
                color: var(--button-text);
            }

            .toolbar-button.blue:hover {
                background-color: var(--button-hover);
            }

            .toolbar-button.green {
                background-color: #16a34a;
                color: var(--button-text);
            }

            .toolbar-button.green:hover {
                background-color: #15803d;
            }

            @keyframes pulse-blue {
                0%,
                100% {
                    background-color: var(--button-bg);
                }
                50% {
                    background-color: #6aa3f8;
                }
            }

            .toolbar-button.pending {
                animation: pulse-blue 1.5s ease-in-out infinite;
            }

            .toolbar-button.pending:hover {
                animation: none;
                background-color: var(--button-hover);
            }

            .rotation-button {
                padding: 12px 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
            }

            /* Toast notifications */
            .toast-container {
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                flex-direction: column;
                gap: 10px;
                z-index: 100;
                pointer-events: none;
            }

            .toast {
                background-color: var(--panel-bg);
                color: var(--text);
                border-radius: 6px;
                box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.15);
                font-size: 14px;
                opacity: 1;
                display: flex;
                align-items: stretch;
                overflow: hidden;
            }

            .toast-icon {
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 12px;
                color: white;
                font-size: 18px;
            }

            .toast-icon.info {
                background-color: #0ea5e9;
            }

            .toast-icon.success {
                background-color: #16a34a;
            }

            .toast-icon.error {
                background-color: #ef4444;
            }

            .toast-message {
                padding: 12px 16px;
                display: flex;
                align-items: center;
            }

            .toast.fade-out {
                animation: toast-out 0.8s ease forwards;
            }

            @keyframes toast-out {
                to {
                    opacity: 0;
                }
            }

            .arrow {
                font-size: 16px;
            }

            /* Floating input panel - top center */
            .input-panel {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                padding: 10px;
                background-color: var(--panel-bg);
                border-radius: 6px;
                border: none;
                box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
                display: flex;
                flex-direction: row;
                gap: 10px;
                z-index: 3;
            }

            .input-panel .toolbar-button {
                padding: 8px 16px;
                white-space: nowrap;
            }
        </style>
    </head>
    <body>
        <div id="canvas"></div>

        <!-- Toast container -->
        <div class="toast-container" id="toastContainer"></div>

        <!-- Floating input panel - top center -->
        <div class="input-panel">
            <button class="toolbar-button green" onclick="pasteFromClipboard()">
                <i class="bx bx-paste"></i> Paste from Hamina
            </button>
            <button
                class="toolbar-button blue"
                id="copyButton"
                onclick="copyOutput()"
            >
                <i class="bx bx-copy"></i> Copy to Clipboard
            </button>
        </div>

        <!-- Left tool menu -->
        <div class="tool-menu">
            <button
                class="tool-button"
                id="rotateTool"
                onclick="toggleTool('rotate')"
                title="Modify Rotation"
            >
                <i class="bx bx-rotate-left"></i>
            </button>
            <button
                class="tool-button"
                id="changeTypeTool"
                onclick="toggleTool('changeType')"
                title="Modify Object Type"
            >
                <i class="bx bx-transfer"></i>
            </button>
            <button
                class="tool-button"
                id="generateCircleTool"
                onclick="toggleTool('generateCircle')"
                title="Generate Circle"
            >
                <i class="bx bx-circle"></i>
            </button>
            <button
                class="tool-button"
                id="generateGridTool"
                onclick="toggleTool('generateGrid')"
                title="Generate Grid"
            >
                <i class="bx bx-grid-alt"></i>
            </button>
            <button
                class="tool-button"
                id="controlsTool"
                onclick="toggleTool('controls')"
                title="Controls"
            >
                <i class="bx bx-info-circle"></i>
            </button>
            <button class="tool-button" onclick="zoomIn()" title="Zoom In">
                <i class="bx bx-zoom-in"></i>
            </button>
            <button class="tool-button" onclick="zoomOut()" title="Zoom Out">
                <i class="bx bx-zoom-out"></i>
            </button>
        </div>

        <!-- Right panel - Rotate tool options -->
        <div id="rotateToolbar" class="toolbar">
            <h3>Rotate Objects</h3>
            <div class="rotation-grid">
                <button
                    class="toolbar-button rotation-button blue"
                    onclick="rotateObjects(radians(-1))"
                >
                    <span class="arrow">↺</span> 1°
                </button>
                <button
                    class="toolbar-button rotation-button blue"
                    onclick="rotateObjects(radians(1))"
                >
                    1° <span class="arrow">↻</span>
                </button>
                <button
                    class="toolbar-button rotation-button blue"
                    onclick="rotateObjects(radians(-5))"
                >
                    <span class="arrow">↺</span> 5°
                </button>
                <button
                    class="toolbar-button rotation-button blue"
                    onclick="rotateObjects(radians(5))"
                >
                    5° <span class="arrow">↻</span>
                </button>
                <button
                    class="toolbar-button rotation-button blue"
                    onclick="rotateObjects(radians(-22.5))"
                >
                    <span class="arrow">↺</span> 22.5°
                </button>
                <button
                    class="toolbar-button rotation-button blue"
                    onclick="rotateObjects(radians(22.5))"
                >
                    22.5° <span class="arrow">↻</span>
                </button>
                <button
                    class="toolbar-button rotation-button blue"
                    onclick="rotateObjects(radians(-45))"
                >
                    <span class="arrow">↺</span> 45°
                </button>
                <button
                    class="toolbar-button rotation-button blue"
                    onclick="rotateObjects(radians(45))"
                >
                    45° <span class="arrow">↻</span>
                </button>
            </div>
        </div>

        <!-- Right panel - Change Type tool options -->
        <div id="changeTypeToolbar" class="toolbar">
            <h3>Convert Zones and Objects</h3>
            <p class="toolbar-description">Convert all zones and objects to:</p>
            <div class="type-options">
                <label class="type-option">
                    <input
                        type="radio"
                        name="targetType"
                        value="attenuatingZone"
                        checked
                    />
                    Attenuating Object
                </label>
                <label class="type-option">
                    <input type="radio" name="targetType" value="holeInclude" />
                    Floor Hole
                </label>
                <label class="type-option">
                    <input type="radio" name="targetType" value="holeExclude" />
                    Building Edge
                </label>
                <label class="type-option">
                    <input
                        type="radio"
                        name="targetType"
                        value="scopeInclude"
                    />
                    Scope Zone
                </label>
                <label class="type-option">
                    <input
                        type="radio"
                        name="targetType"
                        value="capacityZone"
                    />
                    Capacity Zone
                </label>
            </div>
            <button class="toolbar-button blue" onclick="convertObjectType()">
                Convert Zones and Objects
            </button>
        </div>

        <!-- Right panel - Generate Circle tool options -->
        <div id="generateCircleToolbar" class="toolbar">
            <h3>Generate Circle</h3>
            <p class="toolbar-description">Create a circular shape:</p>
            <div class="type-options">
                <label class="type-option">
                    <input
                        type="radio"
                        name="circleType"
                        value="wall"
                        checked
                    />
                    Wall
                </label>
                <label class="type-option">
                    <input
                        type="radio"
                        name="circleType"
                        value="attenuatingZone"
                    />
                    Attenuating Object
                </label>
            </div>
            <div>
                <h3>Segments</h3>
                <input
                    type="number"
                    id="circleSegments"
                    value="18"
                    min="3"
                    max="360"
                    placeholder="Number of segments"
                />
            </div>
            <div>
                <h3>Diameter (Meters)</h3>
                <input
                    type="number"
                    id="circleDiameter"
                    value="6"
                    min="0.1"
                    step="0.1"
                    placeholder="Diameter in meters"
                />
            </div>
            <button class="toolbar-button blue" onclick="generateCircle()">
                Generate Circle
            </button>
        </div>

        <!-- Right panel - Generate Grid tool options -->
        <div id="generateGridToolbar" class="toolbar">
            <h3>Generate Grid</h3>
            <p class="toolbar-description">Create a grid of APs or notes:</p>
            <div class="type-options">
                <label class="type-option">
                    <input
                        type="radio"
                        name="gridType"
                        value="accessPoint"
                        checked
                    />
                    Access Points
                </label>
                <label class="type-option">
                    <input type="radio" name="gridType" value="mapNote" />
                    Map Notes
                </label>
                <label class="type-option">
                    <input type="checkbox" id="gridTriangles" />
                    Triangular Pattern
                </label>
            </div>
            <div>
                <h3>Rows</h3>
                <input
                    type="number"
                    id="gridRows"
                    value="3"
                    min="1"
                    max="100"
                    placeholder="Number of rows"
                />
            </div>
            <div>
                <h3>Columns</h3>
                <input
                    type="number"
                    id="gridColumns"
                    value="3"
                    min="1"
                    max="100"
                    placeholder="Number of columns"
                />
            </div>
            <div>
                <h3>Distance (Meters)</h3>
                <input
                    type="number"
                    id="gridDistance"
                    value="10"
                    min="0.1"
                    step="0.1"
                    placeholder="Distance between points"
                />
            </div>
            <button class="toolbar-button blue" onclick="generateGrid()">
                Generate Grid
            </button>
        </div>

        <!-- Right panel - Controls -->
        <div id="controlsToolbar" class="toolbar">
            <h3>Controls</h3>
            <ul class="controls-list">
                <li>
                    <b>Zoom:</b> Hold <span class="kbd">Shift</span>, drag
                    vertically
                </li>
                <li><b>Zoom:</b> Trackpad pinch-to-zoom</li>
                <li>
                    <b>Pan:</b> Hold <span class="kbd">Spacebar</span>, move
                    mouse
                </li>
                <li><b>Pan:</b> Use scroll wheel/touchpad</li>
            </ul>
        </div>

        <script>
            let objects;
            let rotation = 0;
            let zoomLevel = 1;
            let centerX = 0;
            let centerY = 0;
            let activeTool = null;
            let jsonData = null; // Store the raw JSON string
            let hasPendingChanges = false;

            // Pan/zoom state
            let panX = 0;
            let panY = 0;
            let isPanning = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            let spacebarDown = false;
            let spacebarStartMouseX = 0;
            let spacebarStartMouseY = 0;
            let spacebarStartPanX = 0;
            let spacebarStartPanY = 0;

            // Selection state
            let selectedZone = null; // { type: 'attenuatingZone', index: number }
            let hoveredZone = null; // { type: 'wall', index: number } - for hover effects
            let hoveredPoint = null; // { x, y } in world coords - point near cursor
            let snapTargetPoint = null; // { x, y } in world coords - point to snap to while dragging
            let activeSnaps = []; // Array of { type, snapPoint, lineDir, otherDir } - all active snap indicators
            let draggedPoint = null; // { zoneType: string, zoneIndex: number, pointIndex: number }
            let isDraggingPoint = false;
            let pointOfInterest = null; // { x, y } in world coords - point for X/Y axis snapping
            let previousHoveredPoint = null; // { x, y } - the point hovered before current one
            let axisSnap = null; // { axis: 'x' | 'y' | 'both', poiX, poiY } - active axis snap info
            const POINT_HANDLE_RADIUS = 6; // Radius of point handles in screen pixels
            const EDGE_HIT_TOLERANCE = 8; // Distance tolerance for clicking on edges
            const POINT_HOVER_TOLERANCE = 12; // Distance tolerance for hovering near points
            const SNAP_TOLERANCE = 15; // Distance tolerance for snapping to points
            const ANGLE_SNAP_TOLERANCE = 0.05; // Radians tolerance for angle snapping (~3 degrees)
            const SNAP_INDICATOR_LENGTH = 15; // Length of snap indicator lines in screen pixels
            const AXIS_SNAP_TOLERANCE = 10; // Distance tolerance for X/Y axis snapping to POI

            // AP icon images
            let apIconBase;
            let apIconMask;
            const apIconHotspot = { x: 32, y: 80 };
            const apIconScale = 0.5; // Scale factor for AP icons (adjust as needed)

            // Map note icon images
            let mapNoteIconBase;
            let mapNoteIconMask;
            const mapNoteIconHotspot = { x: 0, y: 64 }; // Bottom left corner of image
            const mapNoteIconScale = 0.5; // Scale factor for map note icons

            function preload() {
                apIconBase = loadImage("images/ap-icon-base.png");
                apIconMask = loadImage("images/ap-icon-mask.png");
                mapNoteIconBase = loadImage("images/map-note-base.png");
                mapNoteIconMask = loadImage("images/map-note-mask.png");
            }

            // ========================================
            // ZONE STYLING CONFIGURATION
            // ========================================
            // Edit these values to adjust the appearance of different zone types.
            // Colors for attenuating objects are derived from their profile color.
            //
            // dashLength: Length of each dash (in canvas units, scaled by zoom)
            // dashGap: Distance between dashes (in canvas units, scaled by zoom)
            // strokeWeight: Width of the dash/stroke line
            // fillOpacity: Opacity of the fill color (0-255, or omit for no fill)
            // strokeDarken: Factor to darken stroke color (0-1, where 0.77 = 77% brightness)

            const zoneStyles = {
                attenuatingZone: {
                    // Color comes from the attenuating zone type profile
                    dashLength: 2,
                    dashGap: 2,
                    strokeWeight: 4,
                    fillOpacity: 128,
                    strokeDarken: 0.77,
                },
                capacityZone: {
                    color: "#4E4F54",
                    dashLength: 2,
                    dashGap: 2,
                    strokeWeight: 2,
                    fillOpacity: 25,
                },
                floorHole: {
                    color: "#85868D",
                    dashLength: 8,
                    dashGap: 8,
                    strokeWeight: 2,
                },
                buildingEdge: {
                    color: "#85868D",
                    dashLength: 8,
                    dashGap: 8,
                    strokeWeight: 2,
                },
                scopeZone: {
                    color: "#85868D",
                    dashLength: 5,
                    dashGap: 5,
                    strokeWeight: 2,
                },
            };
            // ========================================

            function markChangesPending() {
                hasPendingChanges = true;
                const copyButton = document.getElementById("copyButton");
                copyButton.classList.add("pending");
            }

            function clearPendingChanges() {
                hasPendingChanges = false;
                const copyButton = document.getElementById("copyButton");
                copyButton.classList.remove("pending");
            }

            function showToast(message, type = "info", duration = 2500) {
                const container = document.getElementById("toastContainer");
                const toast = document.createElement("div");
                toast.className = "toast";

                // Icon configuration based on type
                const iconConfig = {
                    info: "bx-info-circle",
                    success: "bx-check-circle",
                    error: "bx-error", // alert-octagon equivalent in boxicons
                };

                const iconClass = iconConfig[type] || iconConfig.info;

                // Create icon element
                const iconDiv = document.createElement("div");
                iconDiv.className = `toast-icon ${type}`;
                iconDiv.innerHTML = `<i class="bx ${iconClass}"></i>`;

                // Create message element
                const messageDiv = document.createElement("div");
                messageDiv.className = "toast-message";
                messageDiv.textContent = message;

                toast.appendChild(iconDiv);
                toast.appendChild(messageDiv);
                container.appendChild(toast);

                setTimeout(() => {
                    toast.classList.add("fade-out");
                    setTimeout(() => {
                        toast.remove();
                    }, 300);
                }, duration);
            }

            async function pasteFromClipboard() {
                try {
                    const text = await navigator.clipboard.readText();
                    jsonData = text;
                    if (parseInput(text)) {
                        showToast(
                            "Hamina clipboard pasted to the canvas.",
                            "success",
                        );
                    }
                } catch (error) {
                    console.error("Failed to read clipboard:", error);
                    showToast(
                        "Could not read from clipboard. Please allow clipboard access.",
                        "error",
                    );
                }
            }

            function toggleTool(toolName) {
                const toolButton = document.getElementById(toolName + "Tool");
                const toolbar = document.getElementById(toolName + "Toolbar");

                if (activeTool === toolName) {
                    // Deactivate the tool
                    activeTool = null;
                    toolbar.classList.remove("visible");
                    toolButton.classList.remove("active");
                } else {
                    // Deactivate previous tool if any
                    if (activeTool) {
                        document
                            .getElementById(activeTool + "Tool")
                            .classList.remove("active");
                        document
                            .getElementById(activeTool + "Toolbar")
                            .classList.remove("visible");
                    }
                    // Activate new tool
                    activeTool = toolName;
                    toolbar.classList.add("visible");
                    toolButton.classList.add("active");
                }
            }

            // Default JSON with walls and attenuating zones
            const defaultJSON = `{
              "header": {
                "type": "HaminaClipboard",
                "version": [
                  1,
                  0,
                  0
                ],
                "id": "c84ee30f-5cc3-4cc8-8e0f-d86ad771b77d"
              },
              "walls": [],
              "wallEndpoints": [],
              "wallTypes": [],
              "cableTrays": [],
              "cableTrayEndpoints": [],
              "attenuatingZones": [
                {
                  "typeId": "e95bb6cb-ca84-48a9-b77d-6017a6cf169c",
                  "area": {
                    "type": "Polygon",
                    "coordinates": [
                      [
                        [
                          21.655673476686257,
                          -7.321092576206411
                        ],
                        [
                          21.682665448643277,
                          -7.320012992901411
                        ],
                        [
                          21.712896457235193,
                          -7.269272577587799
                        ],
                        [
                          21.76580072227089,
                          -6.957273002572492
                        ],
                        [
                          21.785631857001984,
                          -6.64644324521214
                        ],
                        [
                          21.788870893636624,
                          -6.5881457467662585
                        ],
                        [
                          21.850412589698923,
                          -6.452118250393141
                        ],
                        [
                          21.813703507837335,
                          -6.425128667779063
                        ],
                        [
                          21.781313141488777,
                          -6.497460749184029
                        ],
                        [
                          21.735966628600853,
                          -6.550360331106731
                        ],
                        [
                          21.6549907127296,
                          -6.496381165879484
                        ],
                        [
                          21.601006768815708,
                          -6.476948666397675
                        ],
                        [
                          21.579127342215212,
                          -6.376770517153545
                        ],
                        [
                          21.56401183791928,
                          -6.469614681344865
                        ],
                        [
                          21.465761059995565,
                          -6.524673429877112
                        ],
                        [
                          21.412856794959847,
                          -6.570015928668454
                        ],
                        [
                          21.37830707085477,
                          -6.514957180136207
                        ],
                        [
                          21.34051831011505,
                          -6.482569680999859
                        ],
                        [
                          21.315685695914368,
                          -6.433988432294882
                        ],
                        [
                          21.272498540783012,
                          -6.46205759821305
                        ],
                        [
                          21.381546107489626,
                          -6.653143843118869
                        ],
                        [
                          21.40127880263379,
                          -6.972811356617058
                        ],
                        [
                          21.432589490103897,
                          -7.253503015800106
                        ],
                        [
                          21.432589490103897,
                          -7.253503015800106
                        ],
                        [
                          21.460661140939482,
                          -7.304243431114173
                        ],
                        [
                          21.497370222801095,
                          -7.326914680510072
                        ],
                        [
                          21.476468878917306,
                          -6.700793778113166
                        ],
                        [
                          21.50562020863092,
                          -6.54317461564915
                        ],
                        [
                          21.582277408988734,
                          -6.498911700162353
                        ],
                        [
                          21.64813782056403,
                          -6.518344199644162
                        ],
                        [
                          21.679448508034252,
                          -6.562607115130959
                        ],
                        [
                          21.67728915027754,
                          -6.943700021636687
                        ]
                      ]
                    ]
                  }
                },
                {
                  "typeId": "e95bb6cb-ca84-48a9-b77d-6017a6cf169c",
                  "area": {
                    "type": "Polygon",
                    "coordinates": [
                      [
                        [
                          21.750450025009563,
                          -6.21896218906295
                        ],
                        [
                          21.757991587361385,
                          -6.243470097061163
                        ],
                        [
                          21.741023072070377,
                          -6.27080584059695
                        ],
                        [
                          21.70802873678234,
                          -6.264207557674581
                        ],
                        [
                          21.69860178384271,
                          -6.24064226152268
                        ],
                        [
                          21.70802873678228,
                          -6.223675248293603
                        ],
                        [
                          21.72499725207327,
                          -6.218962189063404
                        ]
                      ]
                    ]
                  }
                },
                {
                  "typeId": "e95bb6cb-ca84-48a9-b77d-6017a6cf169c",
                  "area": {
                    "type": "Polygon",
                    "coordinates": [
                      [
                        [
                          21.531744716815005,
                          -6.314165985516411
                        ],
                        [
                          21.551541317987656,
                          -6.332075610591346
                        ],
                        [
                          21.55154131798773,
                          -6.358468742281275
                        ],
                        [
                          21.529859326227147,
                          -6.357526130435417
                        ],
                        [
                          21.501578467408752,
                          -6.32830516320746
                        ],
                        [
                          21.511005420348216,
                          -6.31039553813207
                        ]
                      ]
                    ]
                  }
                },
                {
                  "typeId": "e95bb6cb-ca84-48a9-b77d-6017a6cf169c",
                  "area": {
                    "type": "Polygon",
                    "coordinates": [
                      [
                        [
                          21.38562694625379,
                          -6.219904800909262
                        ],
                        [
                          21.403538156838543,
                          -6.234986590446169
                        ],
                        [
                          21.39882468036901,
                          -6.252896215522014
                        ],
                        [
                          21.374314602726482,
                          -6.264207557674581
                        ],
                        [
                          21.3535753062595,
                          -6.2500683799835315
                        ],
                        [
                          21.3535753062595,
                          -6.2500683799835315
                        ],
                        [
                          21.35451800155365,
                          -6.221790024601432
                        ]
                      ]
                    ]
                  }
                },
                {
                  "typeId": "3beb0bf5-b5f0-4e36-9481-5090ca3f9b50",
                  "area": {
                    "type": "Polygon",
                    "coordinates": [
                      [
                        [
                          19.359564820189185,
                          -7.443425306285462
                        ],
                        [
                          19.40143324768089,
                          -7.283578188681986
                        ],
                        [
                          19.519426088794187,
                          -7.108507536068828
                        ],
                        [
                          19.673578026378042,
                          -7.0076516166291185
                        ],
                        [
                          19.932401032691384,
                          -6.925825115951284
                        ],
                        [
                          20.077037418572193,
                          -6.901086871559983
                        ],
                        [
                          20.276864004328818,
                          -6.901086871560437
                        ],
                        [
                          20.440531493615122,
                          -6.8687368596642955
                        ],
                        [
                          20.632745638009613,
                          -6.7964250683676255
                        ],
                        [
                          20.718385603333864,
                          -6.771686823976779
                        ],
                        [
                          20.81163801002011,
                          -6.689860323298944
                        ],
                        [
                          20.866828209895626,
                          -6.668927962660291
                        ],
                        [
                          20.91352829370864,
                          -6.599174932149708
                        ],
                        [
                          20.991555817670818,
                          -6.5535043271202085
                        ],
                        [
                          21.012490031416792,
                          -6.505930780214385
                        ],
                        [
                          21.041036686524915,
                          -6.484998419576186
                        ],
                        [
                          21.08671133469772,
                          -6.46977488456605
                        ],
                        [
                          21.143804644913985,
                          -6.357501313868852
                        ],
                        [
                          21.33030945828688,
                          -6.153886533112654
                        ],
                        [
                          21.406433871908344,
                          -6.106312986206831
                        ],
                        [
                          21.501589388935283,
                          -6.0492247299198425
                        ],
                        [
                          21.575810692216205,
                          -6.03590413678603
                        ],
                        [
                          21.634807112772872,
                          -6.045418846167195
                        ],
                        [
                          21.75877945338849,
                          -6.108609174881167
                        ],
                        [
                          21.853934970415562,
                          -6.2265915712073365
                        ],
                        [
                          21.901512728929166,
                          -6.338865141904989
                        ],
                        [
                          21.926253163356087,
                          -6.4016622238204945
                        ],
                        [
                          21.926253163356158,
                          -6.430206351963989
                        ],
                        [
                          21.970024701188475,
                          -6.572926992681005
                        ],
                        [
                          21.97002470118835,
                          -6.610985830205209
                        ],
                        [
                          21.990958914934485,
                          -6.669977028368521
                        ],
                        [
                          21.994765135615392,
                          -6.75370647092268
                        ],
                        [
                          22.01950557004232,
                          -6.793668250323208
                        ],
                        [
                          22.015699349361412,
                          -6.85265944848652
                        ],
                        [
                          22.049955335491035,
                          -6.907844762897184
                        ],
                        [
                          22.052378993373242,
                          -7.199232943316929
                        ],
                        [
                          22.0561852140544,
                          -7.301991804633417
                        ],
                        [
                          22.01051056588155,
                          -7.478965399122444
                        ],
                        [
                          21.95722347634635,
                          -7.56840366730512
                        ],
                        [
                          21.953417255665244,
                          -7.612171330458295
                        ],
                        [
                          21.913451938513965,
                          -7.657841935487795
                        ],
                        [
                          21.913451938513834,
                          -7.695900773012454
                        ],
                        [
                          21.941998593622095,
                          -7.779630215566613
                        ],
                        [
                          22.08916538548276,
                          -7.875917033673886
                        ],
                        [
                          22.21857688863949,
                          -7.910169987445897
                        ],
                        [
                          22.30992618498534,
                          -7.921587638703386
                        ],
                        [
                          22.330860398731176,
                          -7.934908231836744
                        ],
                        [
                          22.311829295326046,
                          -7.946325883094687
                        ],
                        [
                          22.03207207526657,
                          -7.946325883094232
                        ],
                        [
                          21.807505055083173,
                          -7.917781754950738
                        ],
                        [
                          21.695221544991313,
                          -7.879722917426079
                        ],
                        [
                          21.695221544991313,
                          -7.879722917426079
                        ],
                        [
                          21.65335311749962,
                          -7.85117878928304
                        ],
                        [
                          21.54487582808872,
                          -7.900655278064733
                        ],
                        [
                          21.284149711435017,
                          -7.9368111737130675
                        ],
                        [
                          21.188994194407947,
                          -7.9368111737130675
                        ],
                        [
                          21.181536511967735,
                          -7.992226802809
                        ],
                        [
                          21.111121429367742,
                          -8.043606233467017
                        ],
                        [
                          20.871329526459807,
                          -8.087373896620193
                        ],
                        [
                          20.59918474776279,
                          -8.159685687916863
                        ],
                        [
                          20.467870134265702,
                          -8.173006281050675
                        ],
                        [
                          20.56302565129252,
                          -7.988420919056352
                        ],
                        [
                          20.580153644357537,
                          -7.948459139655824
                        ],
                        [
                          20.673406051043905,
                          -7.8761473483587
                        ],
                        [
                          20.753336685346287,
                          -7.841894394586689
                        ],
                        [
                          20.833267319648908,
                          -7.683950218859536
                        ],
                        [
                          20.892263740205752,
                          -7.634473730077843
                        ],
                        [
                          21.00454725029759,
                          -7.623056078820355
                        ],
                        [
                          21.073059222556896,
                          -7.643988439459008
                        ],
                        [
                          21.128249422432496,
                          -7.6991737538696725
                        ],
                        [
                          21.154892967200226,
                          -7.7714855451663425
                        ],
                        [
                          21.154892967200166,
                          -7.695367870117025
                        ],
                        [
                          21.08447788460006,
                          -7.619250195067707
                        ],
                        [
                          20.97029126416771,
                          -7.5964148925531845
                        ],
                        [
                          20.878941967822144,
                          -7.605929601934349
                        ],
                        [
                          20.810429995562714,
                          -7.670629625726178
                        ],
                        [
                          20.740014912962728,
                          -7.817156150195842
                        ],
                        [
                          20.661987389000718,
                          -7.851409103967853
                        ],
                        [
                          20.551606989249397,
                          -7.944653255903177
                        ],
                        [
                          20.412679934389978,
                          -7.942750314026853
                        ],
                        [
                          20.247109334763216,
                          -7.897079708997353
                        ],
                        [
                          20.163372479779525,
                          -7.79432084768132
                        ],
                        [
                          20.00351121117434,
                          -7.664920800097661
                        ],
                        [
                          19.83032817018504,
                          -7.588803125048344
                        ],
                        [
                          19.693773664901673,
                          -7.5621696974531005
                        ],
                        [
                          19.941178009171782,
                          -7.664928558769589
                        ],
                        [
                          20.129585932885167,
                          -7.801940373858088
                        ],
                        [
                          20.22093522923114,
                          -7.9180198283079335
                        ],
                        [
                          20.205710346506635,
                          -7.944661014575104
                        ],
                        [
                          20.148617036290453,
                          -7.944661014575104
                        ],
                        [
                          20.091523726074385,
                          -7.904699235174121
                        ],
                        [
                          20.08962061573404,
                          -7.9541757239562685
                        ],
                        [
                          20.013496202112293,
                          -7.933243363317615
                        ],
                        [
                          19.96972466428006,
                          -7.91611688643161
                        ],
                        [
                          19.9697246642799,
                          -7.975108084594922
                        ],
                        [
                          19.92785623678795,
                          -7.975108084594467
                        ],
                        [
                          20.02872108483649,
                          -8.026487515252938
                        ],
                        [
                          19.971627774620433,
                          -8.058837527148626
                        ],
                        [
                          19.86695670589077,
                          -8.051225759643785
                        ],
                        [
                          19.86695670589077,
                          -8.051225759643785
                        ],
                        [
                          19.62145547196143,
                          -7.929437479565422
                        ],
                        [
                          19.431144437907413,
                          -7.7733962457145935
                        ],
                        [
                          19.364535575988608,
                          -7.596422651225112
                        ]
                      ]
                    ]
                  }
                },
                {
                  "typeId": "e95bb6cb-ca84-48a9-b77d-6017a6cf169c",
                  "area": {
                    "type": "Polygon",
                    "coordinates": [
                      [
                        [
                          21.633555808560633,
                          -6.312280761823786
                        ],
                        [
                          21.649581628557808,
                          -6.316051209208581
                        ],
                        [
                          21.649581628557783,
                          -6.3330182224376586
                        ],
                        [
                          21.61941537915151,
                          -6.361296577819758
                        ],
                        [
                          21.596790692097137,
                          -6.357526130435417
                        ],
                        [
                          21.59396260621503,
                          -6.336788669821544
                        ],
                        [
                          21.610931121506134,
                          -6.318879044746609
                        ]
                      ]
                    ]
                  }
                }
              ],
              "attenuatingZoneTypes": [
                {
                  "id": "e95bb6cb-ca84-48a9-b77d-6017a6cf169c",
                  "name": "Walrus Features",
                  "color": "#6AABF0",
                  "shortcutKey": "",
                  "topEdge": 1.6,
                  "bottomEdge": null,
                  "attenuationDbPerMeter": 10,
                  "ituRModelEnabled": true,
                  "transparencyEnabled": false
                },
                {
                  "id": "3beb0bf5-b5f0-4e36-9481-5090ca3f9b50",
                  "name": "Walrus Blubber",
                  "color": "#2E6CC7",
                  "shortcutKey": "",
                  "topEdge": 1.4,
                  "bottomEdge": null,
                  "attenuationDbPerMeter": 30,
                  "ituRModelEnabled": true,
                  "transparencyEnabled": false
                }
              ],
              "scopeZones": [],
              "capacityZones": [],
              "holeInFloorZones": [],
              "accessPoints": [],
              "mapNotes": [],
              "tiePoints": [],
              "cableRisers": [],
              "clientDevices": [],
              "networkInfraDevices": [],
              "raisedFloorZones": [],
              "slopedFloors": []
            }`;

            function setup() {
                const canvas = createCanvas(windowWidth, windowHeight);
                canvas.parent("canvas");

                // Load default JSON and render it
                jsonData = defaultJSON;
                parseInput(defaultJSON);
            }

            function draw() {
                background(240);
                translate(width / 2 + panX, height / 2 + panY);
                rotate(rotation);
                scale(zoomLevel);

                // Draw walls first (behind other objects)
                if (
                    objects &&
                    objects.walls &&
                    objects.wallEndpoints &&
                    objects.wallTypes
                ) {
                    drawWalls();
                }

                // Draw attenuating zones
                if (objects && objects.attenuatingZones) {
                    for (let i = 0; i < objects.attenuatingZones.length; i++) {
                        const zone = objects.attenuatingZones[i];
                        const type = objects.attenuatingZoneTypes?.find(
                            (t) => t.id === zone.typeId,
                        );
                        const zoneColor =
                            type && type.color ? type.color : "#7AC2AF";
                        const isSelected =
                            selectedZone &&
                            selectedZone.type === "attenuatingZone" &&
                            selectedZone.index === i;
                        drawZone(
                            zone.area.coordinates[0],
                            zoneColor,
                            zoneStyles.attenuatingZone,
                            isSelected,
                        );
                    }
                }

                // Draw scope zones
                if (objects && objects.scopeZones) {
                    for (let i = 0; i < objects.scopeZones.length; i++) {
                        const zone = objects.scopeZones[i];
                        const isSelected =
                            selectedZone &&
                            selectedZone.type === "scopeZone" &&
                            selectedZone.index === i;
                        drawZone(
                            zone.area.coordinates[0],
                            zoneStyles.scopeZone.color,
                            zoneStyles.scopeZone,
                            isSelected,
                        );
                    }
                }

                // Draw hole in floor zones (INCLUDE = floor hole, EXCLUDE = building edge)
                if (objects && objects.holeInFloorZones) {
                    for (let i = 0; i < objects.holeInFloorZones.length; i++) {
                        const zone = objects.holeInFloorZones[i];
                        const isSelected =
                            selectedZone &&
                            selectedZone.type === "holeInFloorZone" &&
                            selectedZone.index === i;
                        if (zone.type === "INCLUDE") {
                            // Floor hole - shadow inside
                            drawZone(
                                zone.area.coordinates[0],
                                zoneStyles.floorHole.color,
                                zoneStyles.floorHole,
                                isSelected,
                            );
                        } else {
                            // Building edge - shadow outside
                            drawZone(
                                zone.area.coordinates[0],
                                zoneStyles.buildingEdge.color,
                                zoneStyles.buildingEdge,
                                isSelected,
                            );
                        }
                    }
                }

                // Draw capacity zones
                if (objects && objects.capacityZones) {
                    for (let i = 0; i < objects.capacityZones.length; i++) {
                        const zone = objects.capacityZones[i];
                        const isSelected =
                            selectedZone &&
                            selectedZone.type === "capacityZone" &&
                            selectedZone.index === i;
                        drawZone(
                            zone.area.coordinates[0],
                            zoneStyles.capacityZone.color,
                            zoneStyles.capacityZone,
                            isSelected,
                        );
                    }
                }

                // Draw access points
                if (objects && objects.accessPoints) {
                    for (let ap of objects.accessPoints) {
                        const apColor = ap.color || "#4687f0";
                        drawAccessPoint(
                            ap.x - centerX,
                            ap.y - centerY,
                            apColor,
                        );
                    }
                }

                // Draw map notes
                if (objects && objects.mapNotes) {
                    for (let note of objects.mapNotes) {
                        const noteColor = note.color || "#db6921";
                        drawMapNote(
                            note.x - centerX,
                            note.y - centerY,
                            noteColor,
                        );
                    }
                }

                // Draw selection handles (after everything else)
                drawSelectedZoneHandles();

                // Draw hovered point indicator (or snap target when dragging)
                drawHoveredPoint();
            }

            function darkenColor(hexColor, factor) {
                // Convert hex to RGB, multiply by factor, convert back
                let c = color(hexColor);
                let r = Math.round(red(c) * factor);
                let g = Math.round(green(c) * factor);
                let b = Math.round(blue(c) * factor);
                return color(r, g, b);
            }

            function drawZone(
                coordinates,
                zoneColor,
                style,
                isSelected = false,
            ) {
                // Transform coordinates to canvas space
                const canvasCoords = coordinates.map((coord) => [
                    coord[0] - centerX,
                    coord[1] - centerY,
                ]);

                // Draw filled shape (only if fillOpacity is defined)
                if (style.fillOpacity !== undefined) {
                    let c = color(zoneColor);
                    c.setAlpha(style.fillOpacity);
                    fill(c);
                    noStroke();
                    beginShape();
                    for (let coord of canvasCoords) {
                        vertex(coord[0], coord[1]);
                    }
                    endShape(CLOSE);
                }

                // Calculate stroke color (darken if specified)
                let strokeColor = zoneColor;
                if (style.strokeDarken) {
                    strokeColor = darkenColor(zoneColor, style.strokeDarken);
                }

                // Draw outline - solid if selected, dashed otherwise
                if (isSelected) {
                    drawSolidOutline(canvasCoords, strokeColor, style);
                } else {
                    drawDashedOutline(canvasCoords, strokeColor, style);
                }
            }

            function drawAccessPoint(x, y, apColor) {
                // Save current transformation state
                push();

                // Move to AP position
                translate(x, y);

                // Counter-rotate to keep icon upright
                rotate(-rotation);

                // Calculate icon size (scale by apIconScale, and compensate for zoom)
                const iconScale = apIconScale / zoomLevel;
                const drawWidth = apIconBase.width * iconScale;
                const drawHeight = apIconBase.height * iconScale;

                // Offset by hotspot so icon is anchored at bottom center
                const drawX = -apIconHotspot.x * iconScale;
                const drawY = -apIconHotspot.y * iconScale;

                // Draw base icon (white with grey outline)
                noTint();
                image(apIconBase, drawX, drawY, drawWidth, drawHeight);

                // Draw color mask with tint
                tint(apColor);
                image(apIconMask, drawX, drawY, drawWidth, drawHeight);
                noTint();

                // Restore transformation state
                pop();
            }

            function drawMapNote(x, y, noteColor) {
                // Save current transformation state
                push();

                // Move to map note position
                translate(x, y);

                // Counter-rotate to keep icon upright
                rotate(-rotation);

                // Calculate icon size (scale by mapNoteIconScale, and compensate for zoom)
                const iconScale = mapNoteIconScale / zoomLevel;
                const drawWidth = mapNoteIconBase.width * iconScale;
                const drawHeight = mapNoteIconBase.height * iconScale;

                // Offset by hotspot so icon is anchored at bottom left
                const drawX = -mapNoteIconHotspot.x * iconScale;
                const drawY = -mapNoteIconHotspot.y * iconScale;

                // Draw base icon (white with grey outline)
                noTint();
                image(mapNoteIconBase, drawX, drawY, drawWidth, drawHeight);

                // Draw color mask with tint
                tint(noteColor);
                image(mapNoteIconMask, drawX, drawY, drawWidth, drawHeight);
                noTint();

                // Restore transformation state
                pop();
            }

            // Darken a color by a given factor (0.0 to 1.0)
            function darkenColorBy(hexColor, factor) {
                let c = color(hexColor);
                let r = Math.round(red(c) * factor);
                let g = Math.round(green(c) * factor);
                let b = Math.round(blue(c) * factor);
                return color(r, g, b);
            }

            function drawWalls() {
                const wallWidth = 4;
                const borderWidth = 1;
                const totalWidth = wallWidth + borderWidth * 2;
                const borderColor = "#333333";

                // Color darkening factors for hover and selected states
                const hoverDarkenFactor = 0.85;
                const selectedDarkenFactor = 0.7;

                // Collect wall data for rendering
                const wallData = [];
                for (let i = 0; i < objects.walls.length; i++) {
                    const wall = objects.walls[i];
                    const wallType = objects.wallTypes.find(
                        (t) => t.id === wall.materialId,
                    );
                    const startEndpoint = objects.wallEndpoints.find(
                        (e) => e.id === wall.startId,
                    );
                    const endEndpoint = objects.wallEndpoints.find(
                        (e) => e.id === wall.endId,
                    );

                    if (wallType && startEndpoint && endEndpoint) {
                        const isSelected =
                            selectedZone &&
                            selectedZone.type === "wall" &&
                            selectedZone.index === i;
                        const isHovered =
                            hoveredZone &&
                            hoveredZone.type === "wall" &&
                            hoveredZone.index === i;

                        // Determine wall color based on state
                        let wallColor = wallType.color || "#000000";
                        if (isSelected) {
                            wallColor = darkenColorBy(
                                wallColor,
                                selectedDarkenFactor,
                            );
                        } else if (isHovered) {
                            wallColor = darkenColorBy(
                                wallColor,
                                hoverDarkenFactor,
                            );
                        }

                        wallData.push({
                            x1: startEndpoint.x - centerX,
                            y1: startEndpoint.y - centerY,
                            x2: endEndpoint.x - centerX,
                            y2: endEndpoint.y - centerY,
                            color: wallColor,
                            isSelected: isSelected,
                        });
                    }
                }

                // First pass: draw borders (thick lines in border color)
                strokeCap(SQUARE);
                stroke(borderColor);
                strokeWeight(totalWidth / zoomLevel);
                for (let w of wallData) {
                    line(w.x1, w.y1, w.x2, w.y2);
                }

                // Second pass: draw wall fill (thinner lines in wall color)
                // This covers the border where walls meet at endpoints
                strokeWeight(wallWidth / zoomLevel);
                for (let w of wallData) {
                    stroke(w.color);
                    line(w.x1, w.y1, w.x2, w.y2);
                }
            }

            function drawDashedOutline(canvasCoords, strokeColor, style) {
                stroke(strokeColor);
                strokeWeight(style.strokeWeight / zoomLevel);
                strokeCap(SQUARE); // Flat ends instead of rounded
                noFill();

                for (let i = 0; i < canvasCoords.length; i++) {
                    let start = canvasCoords[i];
                    let end = canvasCoords[(i + 1) % canvasCoords.length];
                    drawDashedLine(start[0], start[1], end[0], end[1], style);
                }
            }

            function drawSolidOutline(canvasCoords, strokeColor, style) {
                stroke(strokeColor);
                strokeWeight(style.strokeWeight / zoomLevel);
                strokeCap(SQUARE);
                noFill();

                for (let i = 0; i < canvasCoords.length; i++) {
                    let start = canvasCoords[i];
                    let end = canvasCoords[(i + 1) % canvasCoords.length];
                    line(start[0], start[1], end[0], end[1]);
                }
            }

            function drawDashedLine(x1, y1, x2, y2, style) {
                let dashLength = style.dashLength / zoomLevel;
                let gapLength = style.dashGap / zoomLevel;

                let xd = x2 - x1;
                let yd = y2 - y1;
                let dist = sqrt(xd * xd + yd * yd);
                let dashCount = Math.floor(dist / (dashLength + gapLength));
                let dashRemaining = dist - dashCount * (dashLength + gapLength);

                for (let i = 0; i < dashCount; i++) {
                    let startT = (i * (dashLength + gapLength)) / dist;
                    let endT = startT + dashLength / dist;

                    let sx = lerp(x1, x2, startT);
                    let sy = lerp(y1, y2, startT);
                    let ex = lerp(x1, x2, endT);
                    let ey = lerp(y1, y2, endT);

                    line(sx, sy, ex, ey);
                }

                if (dashRemaining > 0) {
                    let startT = 1 - dashRemaining / dist;
                    line(lerp(x1, x2, startT), lerp(y1, y2, startT), x2, y2);
                }
            }

            function windowResized() {
                resizeCanvas(windowWidth, windowHeight);
            }

            // Pan and zoom controls
            let shiftDown = false;
            let isZooming = false;
            let zoomStartY = 0;
            let zoomStartLevel = 1;
            let zoomStartPanX = 0;
            let zoomStartPanY = 0;
            let zoomAnchorScreenX = 0;
            let zoomAnchorScreenY = 0;

            function mousePressed() {
                if (shiftDown) {
                    isZooming = true;
                    zoomStartY = mouseY;
                    zoomStartLevel = zoomLevel;
                    zoomStartPanX = panX;
                    zoomStartPanY = panY;
                    // Store the screen position where zoom started
                    zoomAnchorScreenX = mouseX;
                    zoomAnchorScreenY = mouseY;
                } else if (mouseButton === RIGHT || mouseButton === CENTER) {
                    isPanning = true;
                    lastMouseX = mouseX;
                    lastMouseY = mouseY;
                    document.body.style.cursor = "grabbing";
                } else if (mouseButton === LEFT && !spacebarDown) {
                    // Check if clicking on a point handle of selected zone
                    const pointHandle = findPointHandleAtPoint(mouseX, mouseY);
                    if (pointHandle) {
                        isDraggingPoint = true;
                        draggedPoint = pointHandle;

                        // If current POI is the point we're about to drag, use previous instead
                        const draggedPos = getPointPosition(pointHandle);
                        if (
                            pointOfInterest &&
                            draggedPos &&
                            Math.abs(pointOfInterest.x - draggedPos.x) <
                                0.0001 &&
                            Math.abs(pointOfInterest.y - draggedPos.y) < 0.0001
                        ) {
                            pointOfInterest = previousHoveredPoint;
                        }

                        document.body.style.cursor = "grabbing";
                        return;
                    }

                    // Check if clicking on a zone edge
                    const clickedZone = findZoneAtPoint(mouseX, mouseY);
                    if (clickedZone) {
                        selectedZone = clickedZone;
                        // Clear POI if it's part of the newly selected zone
                        if (
                            pointOfInterest &&
                            isPointPartOfZone(pointOfInterest, clickedZone)
                        ) {
                            pointOfInterest = null;
                            previousHoveredPoint = null;
                        }
                    } else {
                        // Clicked on empty space - deselect
                        selectedZone = null;
                    }
                }
            }

            function mouseReleased() {
                isPanning = false;
                isZooming = false;
                if (isDraggingPoint) {
                    isDraggingPoint = false;
                    draggedPoint = null;
                    snapTargetPoint = null;
                    activeSnaps = [];
                }
                if (!spacebarDown) {
                    document.body.style.cursor = "default";
                }
            }

            function mouseMoved() {
                // Spacebar + mouse move to pan (no click required)
                if (spacebarDown) {
                    panX = spacebarStartPanX + (mouseX - spacebarStartMouseX);
                    panY = spacebarStartPanY + (mouseY - spacebarStartMouseY);
                    hoveredZone = null;
                    hoveredPoint = null;
                } else if (!isPanning && !isZooming) {
                    // Always check for nearby points to update POI
                    const worldPos = screenToWorld(mouseX, mouseY);
                    const nearestPoint = findNearestPoint(
                        worldPos.x + centerX,
                        worldPos.y + centerY,
                    );
                    const tolerance = POINT_HOVER_TOLERANCE / zoomLevel;

                    let currentPointUnderMouse = null;
                    if (nearestPoint && nearestPoint.distance < tolerance) {
                        currentPointUnderMouse = {
                            x: nearestPoint.x,
                            y: nearestPoint.y,
                        };
                    }

                    // Update POI when moving to a different point
                    // POI rules: can't be part of selected zone, can't be the point being dragged
                    if (currentPointUnderMouse) {
                        const isDifferentPoint =
                            !pointOfInterest ||
                            Math.abs(
                                pointOfInterest.x - currentPointUnderMouse.x,
                            ) > 0.0001 ||
                            Math.abs(
                                pointOfInterest.y - currentPointUnderMouse.y,
                            ) > 0.0001;

                        const isPartOfSelectedZone =
                            selectedZone &&
                            isPointPartOfZone(
                                currentPointUnderMouse,
                                selectedZone,
                            );

                        const isCurrentDraggedPoint =
                            isDraggingPoint &&
                            draggedPoint &&
                            isPointBeingDragged(
                                currentPointUnderMouse,
                                draggedPoint,
                            );

                        if (
                            isDifferentPoint &&
                            !isPartOfSelectedZone &&
                            !isCurrentDraggedPoint
                        ) {
                            // Set current POI as previous, then update POI
                            previousHoveredPoint = pointOfInterest;
                            pointOfInterest = {
                                x: currentPointUnderMouse.x,
                                y: currentPointUnderMouse.y,
                            };
                        }
                    }

                    // Only update hover visuals when not dragging
                    if (!isDraggingPoint) {
                        if (currentPointUnderMouse) {
                            hoveredPoint = currentPointUnderMouse;
                            hoveredZone = null;
                            document.body.style.cursor = "grab";
                        } else {
                            hoveredPoint = null;
                            // Update cursor and hover state based on what's under the mouse
                            const pointHandle = findPointHandleAtPoint(
                                mouseX,
                                mouseY,
                            );
                            if (pointHandle) {
                                document.body.style.cursor = "grab";
                                hoveredZone = null;
                            } else {
                                const zone = findZoneAtPoint(mouseX, mouseY);
                                hoveredZone = zone;
                                if (zone) {
                                    document.body.style.cursor = "pointer";
                                } else {
                                    document.body.style.cursor = "default";
                                }
                            }
                        }
                    }
                }
                lastMouseX = mouseX;
                lastMouseY = mouseY;
            }

            function mouseDragged() {
                if (isDraggingPoint && draggedPoint) {
                    // Convert current mouse position to world coordinates
                    const worldPos = screenToWorld(mouseX, mouseY);
                    let newX = worldPos.x + centerX;
                    let newY = worldPos.y + centerY;

                    // Reset snap state
                    snapTargetPoint = null;
                    activeSnaps = [];
                    axisSnap = null;

                    // Check for snap to existing point (highest priority)
                    const snapTolerance = SNAP_TOLERANCE / zoomLevel;
                    const nearestPoint = findNearestPoint(
                        newX,
                        newY,
                        draggedPoint,
                    );

                    if (nearestPoint && nearestPoint.distance < snapTolerance) {
                        // Snap to the nearest point
                        newX = nearestPoint.x;
                        newY = nearestPoint.y;
                        snapTargetPoint = {
                            x: nearestPoint.x,
                            y: nearestPoint.y,
                        };
                        activeSnaps = [];
                    } else {
                        // Check for angle snaps (colinear or perpendicular)
                        // Try to find a position that satisfies multiple constraints
                        const bestSnap = findBestMultiSnapPosition(
                            newX,
                            newY,
                            draggedPoint,
                        );

                        if (bestSnap) {
                            newX = bestSnap.x;
                            newY = bestSnap.y;
                            activeSnaps = bestSnap.activeSnaps;
                        } else {
                            activeSnaps = [];
                        }

                        // Check for X/Y axis snap to Point of Interest
                        // This works alongside other snaps
                        if (pointOfInterest) {
                            const axisTolerance =
                                AXIS_SNAP_TOLERANCE / zoomLevel;
                            const xDiff = Math.abs(newX - pointOfInterest.x);
                            const yDiff = Math.abs(newY - pointOfInterest.y);

                            // Don't snap to POI if it's the point we're dragging
                            const isPOIDragged =
                                Math.abs(
                                    pointOfInterest.x - (worldPos.x + centerX),
                                ) < 0.0001 &&
                                Math.abs(
                                    pointOfInterest.y - (worldPos.y + centerY),
                                ) < 0.0001;

                            if (!isPOIDragged) {
                                if (
                                    xDiff < axisTolerance &&
                                    yDiff < axisTolerance
                                ) {
                                    // Snap to both X and Y (coincident)
                                    newX = pointOfInterest.x;
                                    newY = pointOfInterest.y;
                                    axisSnap = {
                                        axis: "both",
                                        poiX: pointOfInterest.x,
                                        poiY: pointOfInterest.y,
                                    };
                                } else if (xDiff < axisTolerance) {
                                    // Snap to X axis (vertical alignment)
                                    newX = pointOfInterest.x;
                                    axisSnap = {
                                        axis: "x",
                                        poiX: pointOfInterest.x,
                                        poiY: pointOfInterest.y,
                                    };
                                } else if (yDiff < axisTolerance) {
                                    // Snap to Y axis (horizontal alignment)
                                    newY = pointOfInterest.y;
                                    axisSnap = {
                                        axis: "y",
                                        poiX: pointOfInterest.x,
                                        poiY: pointOfInterest.y,
                                    };
                                }
                            }
                        }
                    }

                    // Handle wall endpoints - moving an endpoint moves all walls connected to it
                    if (
                        draggedPoint.zoneType === "wall" &&
                        draggedPoint.endpointId
                    ) {
                        const endpoint = objects.wallEndpoints?.find(
                            (e) => e.id === draggedPoint.endpointId,
                        );
                        if (endpoint) {
                            endpoint.x = newX;
                            endpoint.y = newY;
                            markChangesPending();
                        }
                    } else {
                        // Handle zone types
                        const coords = getZoneCoords(
                            draggedPoint.zoneType,
                            draggedPoint.zoneIndex,
                        );
                        if (coords && draggedPoint.pointIndex < coords.length) {
                            coords[draggedPoint.pointIndex][0] = newX;
                            coords[draggedPoint.pointIndex][1] = newY;
                            markChangesPending();
                        }
                    }
                } else if (isZooming) {
                    // Drag up to zoom in, drag down to zoom out
                    const dragDistance = zoomStartY - mouseY;
                    const newZoomLevel =
                        zoomStartLevel * Math.pow(1.01, dragDistance);

                    // Calculate world position of anchor at start of zoom
                    const anchorWorldX =
                        (zoomAnchorScreenX - width / 2 - zoomStartPanX) /
                        zoomStartLevel;
                    const anchorWorldY =
                        (zoomAnchorScreenY - height / 2 - zoomStartPanY) /
                        zoomStartLevel;

                    // Calculate new pan to keep anchor point at same screen position
                    panX =
                        zoomAnchorScreenX -
                        width / 2 -
                        anchorWorldX * newZoomLevel;
                    panY =
                        zoomAnchorScreenY -
                        height / 2 -
                        anchorWorldY * newZoomLevel;

                    zoomLevel = newZoomLevel;
                } else if (isPanning) {
                    panX += mouseX - lastMouseX;
                    panY += mouseY - lastMouseY;
                    lastMouseX = mouseX;
                    lastMouseY = mouseY;
                }
            }

            function mouseWheel(event) {
                // Check if this is a pinch-to-zoom (ctrlKey is set) or regular scroll
                if (event.ctrlKey) {
                    // Pinch-to-zoom on trackpad - zoom centered on mouse pointer
                    const oldZoom = zoomLevel;

                    // Calculate world position under mouse before zoom
                    const worldX = (mouseX - width / 2 - panX) / oldZoom;
                    const worldY = (mouseY - height / 2 - panY) / oldZoom;

                    // Use the actual delta for smooth 1:1 pinch-to-zoom
                    // Negative delta = zoom in, positive delta = zoom out
                    const zoomSensitivity = 0.01;
                    zoomLevel *= 1 - event.delta * zoomSensitivity;

                    // Clamp zoom level to reasonable bounds
                    zoomLevel = Math.max(0.01, Math.min(500, zoomLevel));

                    // Adjust pan so the same world point stays under the mouse
                    panX = mouseX - width / 2 - worldX * zoomLevel;
                    panY = mouseY - height / 2 - worldY * zoomLevel;
                } else {
                    // Regular scroll - pan the map
                    panX -= event.deltaX;
                    panY -= event.delta;
                }

                // Prevent default scroll behavior
                return false;
            }

            function zoomIn() {
                // Zoom in centered on the canvas
                const oldZoom = zoomLevel;
                const centerWorldX = (width / 2 - width / 2 - panX) / oldZoom;
                const centerWorldY = (height / 2 - height / 2 - panY) / oldZoom;

                zoomLevel *= 1.5;
                zoomLevel = Math.max(0.01, Math.min(500, zoomLevel));

                panX = width / 2 - width / 2 - centerWorldX * zoomLevel;
                panY = height / 2 - height / 2 - centerWorldY * zoomLevel;
            }

            function zoomOut() {
                // Zoom out centered on the canvas
                const oldZoom = zoomLevel;
                const centerWorldX = (width / 2 - width / 2 - panX) / oldZoom;
                const centerWorldY = (height / 2 - height / 2 - panY) / oldZoom;

                zoomLevel /= 1.5;
                zoomLevel = Math.max(0.01, Math.min(500, zoomLevel));

                panX = width / 2 - width / 2 - centerWorldX * zoomLevel;
                panY = height / 2 - height / 2 - centerWorldY * zoomLevel;
            }

            // Convert screen coordinates to world coordinates (before rotation)
            function screenToWorld(screenX, screenY) {
                // Remove screen center offset and pan
                const x = (screenX - width / 2 - panX) / zoomLevel;
                const y = (screenY - height / 2 - panY) / zoomLevel;

                // Reverse rotation
                const cosR = cos(-rotation);
                const sinR = sin(-rotation);
                const worldX = x * cosR - y * sinR;
                const worldY = x * sinR + y * cosR;

                return { x: worldX, y: worldY };
            }

            // Convert world coordinates to screen coordinates
            function worldToScreen(worldX, worldY) {
                // Apply rotation
                const cosR = cos(rotation);
                const sinR = sin(rotation);
                const rotX = worldX * cosR - worldY * sinR;
                const rotY = worldX * sinR + worldY * cosR;

                // Apply zoom and pan
                const screenX = rotX * zoomLevel + width / 2 + panX;
                const screenY = rotY * zoomLevel + height / 2 + panY;

                return { x: screenX, y: screenY };
            }

            // Calculate distance from point to line segment
            function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const lengthSquared = dx * dx + dy * dy;

                if (lengthSquared === 0) {
                    // Segment is a point
                    return Math.sqrt(
                        (px - x1) * (px - x1) + (py - y1) * (py - y1),
                    );
                }

                // Calculate projection parameter
                let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
                t = Math.max(0, Math.min(1, t));

                // Find closest point on segment
                const closestX = x1 + t * dx;
                const closestY = y1 + t * dy;

                return Math.sqrt(
                    (px - closestX) * (px - closestX) +
                        (py - closestY) * (py - closestY),
                );
            }

            // Check if a screen point is near a zone edge or wall
            function findZoneAtPoint(screenX, screenY) {
                if (!objects) return null;

                const worldPos = screenToWorld(screenX, screenY);
                const tolerance = EDGE_HIT_TOLERANCE / zoomLevel;

                // Helper to check zone edges
                function checkZoneEdges(zones, typeName) {
                    if (!zones) return null;
                    for (let i = 0; i < zones.length; i++) {
                        const zone = zones[i];
                        const coords = zone.area.coordinates[0];

                        for (let j = 0; j < coords.length; j++) {
                            const x1 = coords[j][0] - centerX;
                            const y1 = coords[j][1] - centerY;
                            const x2 =
                                coords[(j + 1) % coords.length][0] - centerX;
                            const y2 =
                                coords[(j + 1) % coords.length][1] - centerY;

                            const dist = pointToSegmentDistance(
                                worldPos.x,
                                worldPos.y,
                                x1,
                                y1,
                                x2,
                                y2,
                            );
                            if (dist < tolerance) {
                                return { type: typeName, index: i };
                            }
                        }
                    }
                    return null;
                }

                // Check all zone types
                let result = checkZoneEdges(
                    objects.attenuatingZones,
                    "attenuatingZone",
                );
                if (result) return result;

                result = checkZoneEdges(objects.scopeZones, "scopeZone");
                if (result) return result;

                result = checkZoneEdges(
                    objects.holeInFloorZones,
                    "holeInFloorZone",
                );
                if (result) return result;

                result = checkZoneEdges(objects.capacityZones, "capacityZone");
                if (result) return result;

                // Check walls
                if (objects.walls && objects.wallEndpoints) {
                    for (let i = 0; i < objects.walls.length; i++) {
                        const wall = objects.walls[i];
                        const startEndpoint = objects.wallEndpoints.find(
                            (e) => e.id === wall.startId,
                        );
                        const endEndpoint = objects.wallEndpoints.find(
                            (e) => e.id === wall.endId,
                        );

                        if (startEndpoint && endEndpoint) {
                            const x1 = startEndpoint.x - centerX;
                            const y1 = startEndpoint.y - centerY;
                            const x2 = endEndpoint.x - centerX;
                            const y2 = endEndpoint.y - centerY;

                            const dist = pointToSegmentDistance(
                                worldPos.x,
                                worldPos.y,
                                x1,
                                y1,
                                x2,
                                y2,
                            );
                            if (dist < tolerance) {
                                return { type: "wall", index: i };
                            }
                        }
                    }
                }

                return null;
            }

            // Check if a point is part of a selected zone
            function isPointPartOfZone(point, zone) {
                if (!point || !zone || !objects) return false;

                if (zone.type === "wall") {
                    const wall = objects.walls?.[zone.index];
                    if (!wall) return false;

                    const startEndpoint = objects.wallEndpoints?.find(
                        (e) => e.id === wall.startId,
                    );
                    const endEndpoint = objects.wallEndpoints?.find(
                        (e) => e.id === wall.endId,
                    );

                    if (
                        startEndpoint &&
                        Math.abs(startEndpoint.x - point.x) < 0.0001 &&
                        Math.abs(startEndpoint.y - point.y) < 0.0001
                    ) {
                        return true;
                    }
                    if (
                        endEndpoint &&
                        Math.abs(endEndpoint.x - point.x) < 0.0001 &&
                        Math.abs(endEndpoint.y - point.y) < 0.0001
                    ) {
                        return true;
                    }
                    return false;
                }

                // For zones, check all vertices
                const coords = getZoneCoords(zone.type, zone.index);
                if (!coords) return false;

                for (const coord of coords) {
                    if (
                        Math.abs(coord[0] - point.x) < 0.0001 &&
                        Math.abs(coord[1] - point.y) < 0.0001
                    ) {
                        return true;
                    }
                }
                return false;
            }

            // Check if a point is the one currently being dragged
            function isPointBeingDragged(point, dragPoint) {
                if (!point || !dragPoint) return false;
                const draggedPos = getPointPosition(dragPoint);
                if (!draggedPos) return false;
                return (
                    Math.abs(draggedPos.x - point.x) < 0.0001 &&
                    Math.abs(draggedPos.y - point.y) < 0.0001
                );
            }

            // Get the world position of a point handle
            function getPointPosition(pointHandle) {
                if (!pointHandle || !objects) return null;

                if (pointHandle.zoneType === "wall" && pointHandle.endpointId) {
                    const endpoint = objects.wallEndpoints?.find(
                        (e) => e.id === pointHandle.endpointId,
                    );
                    return endpoint ? { x: endpoint.x, y: endpoint.y } : null;
                }

                const coords = getZoneCoords(
                    pointHandle.zoneType,
                    pointHandle.zoneIndex,
                );
                if (coords && pointHandle.pointIndex < coords.length) {
                    return {
                        x: coords[pointHandle.pointIndex][0],
                        y: coords[pointHandle.pointIndex][1],
                    };
                }
                return null;
            }

            // Helper to get zone coordinates by type and index
            function getZoneCoords(type, index) {
                if (!objects) return null;
                let zone = null;
                switch (type) {
                    case "attenuatingZone":
                        zone = objects.attenuatingZones?.[index];
                        break;
                    case "scopeZone":
                        zone = objects.scopeZones?.[index];
                        break;
                    case "holeInFloorZone":
                        zone = objects.holeInFloorZones?.[index];
                        break;
                    case "capacityZone":
                        zone = objects.capacityZones?.[index];
                        break;
                }
                return zone ? zone.area.coordinates[0] : null;
            }

            // Get the connected segments for a point being dragged
            // Returns array of { x, y } representing the "other end" of each connected segment
            function getConnectedSegmentEndpoints(dragPoint) {
                if (!objects || !dragPoint) return [];

                const endpoints = [];

                if (dragPoint.zoneType === "wall" && dragPoint.endpointId) {
                    // For walls, find all walls that share this endpoint
                    if (objects.walls && objects.wallEndpoints) {
                        for (const wall of objects.walls) {
                            let otherEndpointId = null;
                            if (wall.startId === dragPoint.endpointId) {
                                otherEndpointId = wall.endId;
                            } else if (wall.endId === dragPoint.endpointId) {
                                otherEndpointId = wall.startId;
                            }
                            if (otherEndpointId) {
                                const otherEndpoint =
                                    objects.wallEndpoints.find(
                                        (e) => e.id === otherEndpointId,
                                    );
                                if (otherEndpoint) {
                                    endpoints.push({
                                        x: otherEndpoint.x,
                                        y: otherEndpoint.y,
                                    });
                                }
                            }
                        }
                    }
                } else {
                    // For zones, get the adjacent points in the polygon
                    const coords = getZoneCoords(
                        dragPoint.zoneType,
                        dragPoint.zoneIndex,
                    );
                    if (coords && dragPoint.pointIndex !== undefined) {
                        const len = coords.length;
                        const idx = dragPoint.pointIndex;
                        // Previous point
                        const prevIdx = (idx - 1 + len) % len;
                        endpoints.push({
                            x: coords[prevIdx][0],
                            y: coords[prevIdx][1],
                        });
                        // Next point
                        const nextIdx = (idx + 1) % len;
                        endpoints.push({
                            x: coords[nextIdx][0],
                            y: coords[nextIdx][1],
                        });
                    }
                }

                return endpoints;
            }

            // Find the best position that satisfies multiple angle snap constraints simultaneously
            // For example, a T-junction where 3 walls meet should snap to satisfy all 3 angles at once
            function findBestMultiSnapPosition(newX, newY, dragPoint) {
                const connectedEndpoints =
                    getConnectedSegmentEndpoints(dragPoint);
                if (connectedEndpoints.length === 0) return null;

                const tolerance = ANGLE_SNAP_TOLERANCE;

                // Collect all possible constraint lines from each connected endpoint
                // Each constraint is a line defined by: pivot point + direction
                const constraints = [];

                for (const endpoint of connectedEndpoints) {
                    const otherSegments = getOtherConnectedSegments(
                        endpoint,
                        dragPoint,
                    );

                    // For each reference segment at this endpoint, calculate the snap angles
                    for (const ref of otherSegments) {
                        const rdx = ref.x - endpoint.x;
                        const rdy = ref.y - endpoint.y;
                        const rlen = Math.sqrt(rdx * rdx + rdy * rdy);
                        if (rlen < 0.001) continue;

                        const refAngle = Math.atan2(rdy, rdx);

                        // Colinear constraint (180° from reference)
                        constraints.push({
                            pivotX: endpoint.x,
                            pivotY: endpoint.y,
                            angle: refAngle + Math.PI,
                            snapType: "colinear",
                            refAngle: refAngle,
                        });

                        // Perpendicular constraints (90° from reference)
                        constraints.push({
                            pivotX: endpoint.x,
                            pivotY: endpoint.y,
                            angle: refAngle + Math.PI / 2,
                            snapType: "perpendicular",
                            refAngle: refAngle,
                        });
                        constraints.push({
                            pivotX: endpoint.x,
                            pivotY: endpoint.y,
                            angle: refAngle - Math.PI / 2,
                            snapType: "perpendicular",
                            refAngle: refAngle,
                        });
                    }
                }

                // Also add colinear constraints at the dragged point itself
                // These check if segments from the dragged point to connected endpoints are colinear
                // (Perpendicular constraints at dragged point form a circle, not a line, so we skip them)
                if (connectedEndpoints.length >= 2) {
                    for (let i = 0; i < connectedEndpoints.length; i++) {
                        for (
                            let j = i + 1;
                            j < connectedEndpoints.length;
                            j++
                        ) {
                            constraints.push({
                                atDraggedPoint: true,
                                snapType: "colinear",
                                endpoint1: connectedEndpoints[i],
                                endpoint2: connectedEndpoints[j],
                            });
                        }
                    }
                }

                if (constraints.length === 0) return null;

                // Helper to check if a position satisfies a constraint
                function satisfiesConstraint(x, y, constraint) {
                    if (constraint.atDraggedPoint) {
                        // For colinear constraints at the dragged point, check if
                        // the point lies on the line through endpoint1 and endpoint2
                        const ep1 = constraint.endpoint1;
                        const ep2 = constraint.endpoint2;

                        const dx1 = ep1.x - x;
                        const dy1 = ep1.y - y;
                        const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);

                        const dx2 = ep2.x - x;
                        const dy2 = ep2.y - y;
                        const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);

                        if (len1 < 0.001 || len2 < 0.001) return false;

                        const angle1 = Math.atan2(dy1, dx1);
                        const angle2 = Math.atan2(dy2, dx2);
                        const angleBetween = Math.abs(
                            normalizeAngle(angle1 - angle2),
                        );

                        // Segments should be 180° apart (straight line through dragged point)
                        return Math.abs(angleBetween - Math.PI) < tolerance;
                    }

                    // For constraints at connected endpoints (not the dragged point)
                    const dx = x - constraint.pivotX;
                    const dy = y - constraint.pivotY;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len < 0.001) return true; // At the pivot, considered satisfied

                    const actualAngle = Math.atan2(dy, dx);
                    const diff = normalizeAngle(actualAngle - constraint.angle);
                    return Math.abs(diff) < tolerance;
                }

                // Helper to get the constraint line (point + angle) for any constraint
                function getConstraintLine(c) {
                    if (c.atDraggedPoint) {
                        // Colinear constraint: line through endpoint1 and endpoint2
                        const dx = c.endpoint2.x - c.endpoint1.x;
                        const dy = c.endpoint2.y - c.endpoint1.y;
                        return {
                            px: c.endpoint1.x,
                            py: c.endpoint1.y,
                            angle: Math.atan2(dy, dx),
                        };
                    }
                    return {
                        px: c.pivotX,
                        py: c.pivotY,
                        angle: c.angle,
                    };
                }

                // Helper to find intersection of two lines
                // Line 1: point (p1x, p1y) with direction angle a1
                // Line 2: point (p2x, p2y) with direction angle a2
                function lineIntersection(p1x, p1y, a1, p2x, p2y, a2) {
                    const d1x = Math.cos(a1);
                    const d1y = Math.sin(a1);
                    const d2x = Math.cos(a2);
                    const d2y = Math.sin(a2);

                    // Check if lines are parallel
                    const cross = d1x * d2y - d1y * d2x;
                    if (Math.abs(cross) < 0.0001) return null;

                    // Solve for t: p1 + t*d1 = p2 + s*d2
                    const t = ((p2x - p1x) * d2y - (p2y - p1y) * d2x) / cross;

                    return {
                        x: p1x + t * d1x,
                        y: p1y + t * d1y,
                    };
                }

                // Try to find a position that satisfies multiple constraints
                // Strategy: Try intersections of constraint pairs, check how many total constraints are satisfied

                let bestPosition = null;
                let bestSatisfiedCount = 0;
                let bestActiveSnaps = [];

                // First, check if the current position already satisfies any constraints
                const satisfiedAtCurrent = constraints.filter((c) =>
                    satisfiesConstraint(newX, newY, c),
                );

                if (satisfiedAtCurrent.length > 0) {
                    // Project onto the first satisfied constraint to get a snapped position
                    const c = satisfiedAtCurrent[0];
                    const line = getConstraintLine(c);

                    if (line) {
                        const dx = newX - line.px;
                        const dy = newY - line.py;
                        const len = Math.sqrt(dx * dx + dy * dy);

                        bestPosition = {
                            x: line.px + len * Math.cos(line.angle),
                            y: line.py + len * Math.sin(line.angle),
                        };
                        bestSatisfiedCount = satisfiedAtCurrent.length;
                    } else {
                        // For non-line constraints (perpendicular at dragged point),
                        // just use current position if it satisfies
                        bestPosition = { x: newX, y: newY };
                        bestSatisfiedCount = satisfiedAtCurrent.length;
                    }
                }

                // Try intersections of all constraint pairs
                for (let i = 0; i < constraints.length; i++) {
                    for (let j = i + 1; j < constraints.length; j++) {
                        const c1 = constraints[i];
                        const c2 = constraints[j];

                        const line1 = getConstraintLine(c1);
                        const line2 = getConstraintLine(c2);

                        // Skip if either constraint doesn't have a line representation
                        if (!line1 || !line2) continue;

                        const intersection = lineIntersection(
                            line1.px,
                            line1.py,
                            line1.angle,
                            line2.px,
                            line2.py,
                            line2.angle,
                        );

                        if (!intersection) continue;

                        // Check distance from current position - don't snap too far
                        const snapDist = Math.sqrt(
                            (intersection.x - newX) ** 2 +
                                (intersection.y - newY) ** 2,
                        );
                        const maxSnapDist = (SNAP_TOLERANCE * 3) / zoomLevel;
                        if (snapDist > maxSnapDist) continue;

                        // Count how many constraints this intersection satisfies
                        const satisfied = constraints.filter((c) =>
                            satisfiesConstraint(
                                intersection.x,
                                intersection.y,
                                c,
                            ),
                        );

                        // Prefer positions that satisfy more constraints
                        // If equal, prefer closer positions
                        if (
                            satisfied.length > bestSatisfiedCount ||
                            (satisfied.length === bestSatisfiedCount &&
                                bestPosition &&
                                snapDist <
                                    Math.sqrt(
                                        (bestPosition.x - newX) ** 2 +
                                            (bestPosition.y - newY) ** 2,
                                    ))
                        ) {
                            bestPosition = intersection;
                            bestSatisfiedCount = satisfied.length;
                        }
                    }
                }

                if (!bestPosition || bestSatisfiedCount === 0) return null;

                // Check if the position actually moved (snap is in effect)
                const snapDelta = Math.sqrt(
                    (bestPosition.x - newX) ** 2 + (bestPosition.y - newY) ** 2,
                );
                const minSnapDelta = 0.0001; // Minimum movement to consider it a snap
                if (snapDelta < minSnapDelta) {
                    // Position didn't change - no snap is active
                    return null;
                }

                // Build the activeSnaps array for the best position
                for (const c of constraints) {
                    if (
                        satisfiesConstraint(bestPosition.x, bestPosition.y, c)
                    ) {
                        // For constraints at the dragged point, use the new position as snap point
                        // and recalculate the direction based on actual segment directions
                        let snapPoint, lineDir, otherDir;

                        if (c.atDraggedPoint) {
                            // Colinear constraint at dragged point - show line indicator
                            snapPoint = {
                                x: bestPosition.x,
                                y: bestPosition.y,
                            };
                            const dx = c.endpoint1.x - bestPosition.x;
                            const dy = c.endpoint1.y - bestPosition.y;
                            const len = Math.sqrt(dx * dx + dy * dy);
                            if (len > 0.001) {
                                lineDir = { x: dx / len, y: dy / len };
                            }
                        } else {
                            snapPoint = { x: c.pivotX, y: c.pivotY };

                            // For the indicator, show actual segment directions from the pivot
                            // lineDir: direction from pivot to the dragged point (snapped position)
                            // otherDir: direction from pivot to the reference segment's other end
                            const toDraggedX = bestPosition.x - c.pivotX;
                            const toDraggedY = bestPosition.y - c.pivotY;
                            const toDraggedLen = Math.sqrt(
                                toDraggedX * toDraggedX +
                                    toDraggedY * toDraggedY,
                            );

                            if (toDraggedLen > 0.001) {
                                lineDir = {
                                    x: toDraggedX / toDraggedLen,
                                    y: toDraggedY / toDraggedLen,
                                };
                            } else {
                                lineDir = {
                                    x: Math.cos(c.angle),
                                    y: Math.sin(c.angle),
                                };
                            }

                            if (c.snapType === "perpendicular") {
                                // otherDir points along the reference segment (away from pivot)
                                otherDir = {
                                    x: Math.cos(c.refAngle),
                                    y: Math.sin(c.refAngle),
                                };
                            }
                        }

                        if (snapPoint && lineDir) {
                            const snapInfo = {
                                type: c.snapType,
                                lineDir: lineDir,
                                snapPoint: snapPoint,
                            };
                            if (otherDir) {
                                snapInfo.otherDir = otherDir;
                            }
                            bestActiveSnaps.push(snapInfo);
                        }
                    }
                }

                // Deduplicate: show only one indicator per pivot point, prioritized by type
                // Priority: colinear > perpendicular
                const snapsByPivot = new Map();
                for (const snap of bestActiveSnaps) {
                    const key = `${snap.snapPoint.x.toFixed(6)},${snap.snapPoint.y.toFixed(6)}`;
                    const existing = snapsByPivot.get(key);
                    if (!existing) {
                        snapsByPivot.set(key, snap);
                    } else {
                        // colinear has higher priority than perpendicular
                        if (
                            snap.type === "colinear" &&
                            existing.type === "perpendicular"
                        ) {
                            snapsByPivot.set(key, snap);
                        }
                    }
                }
                bestActiveSnaps = Array.from(snapsByPivot.values());

                return {
                    x: bestPosition.x,
                    y: bestPosition.y,
                    activeSnaps: bestActiveSnaps,
                };
            }

            // Collect all angle snaps - checks for colinear and perpendicular constraints at all joints
            // Returns array of { snappedX, snappedY, snapType, lineDir, otherDir, snapPoint }
            function collectAllAngleSnaps(newX, newY, dragPoint) {
                const connectedEndpoints =
                    getConnectedSegmentEndpoints(dragPoint);
                if (connectedEndpoints.length === 0) return [];

                const tolerance = ANGLE_SNAP_TOLERANCE;
                const snaps = [];

                // Helper function to collect angle snaps at a given pivot point
                function collectAngleSnapsAtPivot(
                    pivotX,
                    pivotY,
                    targetX,
                    targetY,
                    referenceSegments,
                ) {
                    const results = [];
                    // Vector from pivot to target (the segment we're checking)
                    const dx = targetX - pivotX;
                    const dy = targetY - pivotY;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    if (len < 0.001) return results;

                    const currentAngle = Math.atan2(dy, dx);

                    for (const ref of referenceSegments) {
                        const rdx = ref.x - pivotX;
                        const rdy = ref.y - pivotY;
                        const rlen = Math.sqrt(rdx * rdx + rdy * rdy);
                        if (rlen < 0.001) continue;

                        const refAngle = Math.atan2(rdy, rdx);

                        // Check for colinear (180° difference)
                        const straightAngle = refAngle + Math.PI;
                        const straightDiff = normalizeAngle(
                            currentAngle - straightAngle,
                        );
                        if (Math.abs(straightDiff) < tolerance) {
                            results.push({
                                snappedX:
                                    pivotX + len * Math.cos(straightAngle),
                                snappedY:
                                    pivotY + len * Math.sin(straightAngle),
                                snapType: "colinear",
                                lineDir: {
                                    x: Math.cos(straightAngle),
                                    y: Math.sin(straightAngle),
                                },
                                snapPoint: { x: pivotX, y: pivotY },
                            });
                        }

                        // Check for perpendicular (90° angles)
                        const rightAngle1 = refAngle + Math.PI / 2;
                        const rightAngle2 = refAngle - Math.PI / 2;

                        if (
                            Math.abs(
                                normalizeAngle(currentAngle - rightAngle1),
                            ) < tolerance
                        ) {
                            results.push({
                                snappedX: pivotX + len * Math.cos(rightAngle1),
                                snappedY: pivotY + len * Math.sin(rightAngle1),
                                snapType: "perpendicular",
                                lineDir: {
                                    x: Math.cos(rightAngle1),
                                    y: Math.sin(rightAngle1),
                                },
                                otherDir: {
                                    x: Math.cos(refAngle),
                                    y: Math.sin(refAngle),
                                },
                                snapPoint: { x: pivotX, y: pivotY },
                            });
                        }
                        if (
                            Math.abs(
                                normalizeAngle(currentAngle - rightAngle2),
                            ) < tolerance
                        ) {
                            results.push({
                                snappedX: pivotX + len * Math.cos(rightAngle2),
                                snappedY: pivotY + len * Math.sin(rightAngle2),
                                snapType: "perpendicular",
                                lineDir: {
                                    x: Math.cos(rightAngle2),
                                    y: Math.sin(rightAngle2),
                                },
                                otherDir: {
                                    x: Math.cos(refAngle),
                                    y: Math.sin(refAngle),
                                },
                                snapPoint: { x: pivotX, y: pivotY },
                            });
                        }
                    }
                    return results;
                }

                // Check 1: Angle snap at the far end of connected segments
                // (where the dragged point's segments connect to other segments)
                for (const endpoint of connectedEndpoints) {
                    const otherSegments = getOtherConnectedSegments(
                        endpoint,
                        dragPoint,
                    );
                    const results = collectAngleSnapsAtPivot(
                        endpoint.x,
                        endpoint.y,
                        newX,
                        newY,
                        otherSegments,
                    );
                    snaps.push(...results);
                }

                return snaps;
            }

            // Normalize angle to [-π, π]
            function normalizeAngle(angle) {
                while (angle > Math.PI) angle -= 2 * Math.PI;
                while (angle < -Math.PI) angle += 2 * Math.PI;
                return angle;
            }

            // Get segments connected to a point, excluding the dragged segment
            function getOtherConnectedSegments(endpoint, dragPoint) {
                const segments = [];
                if (!objects) return segments;

                // For walls, find other walls sharing this endpoint
                if (objects.walls && objects.wallEndpoints) {
                    for (const wall of objects.walls) {
                        let otherEndpointId = null;
                        if (
                            wall.startId === findEndpointIdAtPosition(endpoint)
                        ) {
                            otherEndpointId = wall.endId;
                        } else if (
                            wall.endId === findEndpointIdAtPosition(endpoint)
                        ) {
                            otherEndpointId = wall.startId;
                        }
                        if (
                            otherEndpointId &&
                            otherEndpointId !== dragPoint.endpointId
                        ) {
                            const otherEndpoint = objects.wallEndpoints.find(
                                (e) => e.id === otherEndpointId,
                            );
                            if (otherEndpoint) {
                                segments.push({
                                    x: otherEndpoint.x,
                                    y: otherEndpoint.y,
                                });
                            }
                        }
                    }
                }

                // For zones, check if this endpoint matches any zone vertices
                const zoneTypes = [
                    { arr: objects.attenuatingZones, name: "attenuatingZone" },
                    { arr: objects.scopeZones, name: "scopeZone" },
                    { arr: objects.holeInFloorZones, name: "holeInFloorZone" },
                    { arr: objects.capacityZones, name: "capacityZone" },
                ];

                for (const { arr, name } of zoneTypes) {
                    if (!arr) continue;
                    for (let i = 0; i < arr.length; i++) {
                        const coords = arr[i].area.coordinates[0];
                        for (let j = 0; j < coords.length; j++) {
                            if (
                                Math.abs(coords[j][0] - endpoint.x) < 0.0001 &&
                                Math.abs(coords[j][1] - endpoint.y) < 0.0001
                            ) {
                                // This is a matching vertex, get adjacent points
                                // but exclude the one we're dragging
                                const len = coords.length;
                                const prevIdx = (j - 1 + len) % len;
                                const nextIdx = (j + 1) % len;

                                // Check if prev/next is the dragged point
                                const isDraggedPrev =
                                    dragPoint.zoneType === name &&
                                    dragPoint.zoneIndex === i &&
                                    dragPoint.pointIndex === prevIdx;
                                const isDraggedNext =
                                    dragPoint.zoneType === name &&
                                    dragPoint.zoneIndex === i &&
                                    dragPoint.pointIndex === nextIdx;

                                if (!isDraggedPrev) {
                                    segments.push({
                                        x: coords[prevIdx][0],
                                        y: coords[prevIdx][1],
                                    });
                                }
                                if (!isDraggedNext) {
                                    segments.push({
                                        x: coords[nextIdx][0],
                                        y: coords[nextIdx][1],
                                    });
                                }
                            }
                        }
                    }
                }

                return segments;
            }

            // Find endpoint ID at a given position
            function findEndpointIdAtPosition(pos) {
                if (!objects || !objects.wallEndpoints) return null;
                for (const endpoint of objects.wallEndpoints) {
                    if (
                        Math.abs(endpoint.x - pos.x) < 0.0001 &&
                        Math.abs(endpoint.y - pos.y) < 0.0001
                    ) {
                        return endpoint.id;
                    }
                }
                return null;
            }

            // Find the nearest point across all objects to a given world position
            // Returns { x, y, distance } or null if no points found
            // excludePoint can be { zoneType, zoneIndex, pointIndex } or { zoneType, zoneIndex, endpointId } to exclude
            function findNearestPoint(worldX, worldY, excludePoint = null) {
                if (!objects) return null;

                let nearest = null;
                let minDist = Infinity;

                // Helper to check if a point should be excluded
                function isExcluded(type, index, pointIdx, endpointId = null) {
                    if (!excludePoint) return false;

                    // For wall endpoints, check endpointId directly (walls can share endpoints)
                    if (
                        type === "wall" &&
                        endpointId &&
                        excludePoint.endpointId === endpointId
                    ) {
                        return true;
                    }

                    // For zones, check type, index, and point index
                    if (excludePoint.zoneType !== type) return false;
                    if (excludePoint.zoneIndex !== index) return false;
                    if (
                        pointIdx !== undefined &&
                        excludePoint.pointIndex === pointIdx
                    )
                        return true;
                    return false;
                }

                // Helper to check a point
                function checkPoint(
                    x,
                    y,
                    type,
                    index,
                    pointIdx,
                    endpointId = null,
                ) {
                    if (isExcluded(type, index, pointIdx, endpointId)) return;
                    const dx = x - worldX;
                    const dy = y - worldY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = { x, y, distance: dist };
                    }
                }

                // Check all zone types
                const zoneTypes = [
                    { arr: objects.attenuatingZones, name: "attenuatingZone" },
                    { arr: objects.scopeZones, name: "scopeZone" },
                    { arr: objects.holeInFloorZones, name: "holeInFloorZone" },
                    { arr: objects.capacityZones, name: "capacityZone" },
                ];

                for (const { arr, name } of zoneTypes) {
                    if (!arr) continue;
                    for (let i = 0; i < arr.length; i++) {
                        const coords = arr[i].area.coordinates[0];
                        for (let j = 0; j < coords.length; j++) {
                            checkPoint(coords[j][0], coords[j][1], name, i, j);
                        }
                    }
                }

                // Check wall endpoints
                if (objects.wallEndpoints) {
                    for (const endpoint of objects.wallEndpoints) {
                        // Find which wall this endpoint belongs to for exclusion check
                        let wallIndex = -1;
                        if (objects.walls) {
                            wallIndex = objects.walls.findIndex(
                                (w) =>
                                    w.startId === endpoint.id ||
                                    w.endId === endpoint.id,
                            );
                        }
                        checkPoint(
                            endpoint.x,
                            endpoint.y,
                            "wall",
                            wallIndex,
                            undefined,
                            endpoint.id,
                        );
                    }
                }

                return nearest;
            }

            // Get wall endpoints for a selected wall (returns array of {endpointId, x, y})
            function getWallEndpointHandles(wallIndex) {
                if (!objects || !objects.walls || !objects.wallEndpoints)
                    return [];
                const wall = objects.walls[wallIndex];
                if (!wall) return [];

                const handles = [];
                const startEndpoint = objects.wallEndpoints.find(
                    (e) => e.id === wall.startId,
                );
                const endEndpoint = objects.wallEndpoints.find(
                    (e) => e.id === wall.endId,
                );

                if (startEndpoint) {
                    handles.push({
                        endpointId: startEndpoint.id,
                        x: startEndpoint.x,
                        y: startEndpoint.y,
                    });
                }
                if (endEndpoint) {
                    handles.push({
                        endpointId: endEndpoint.id,
                        x: endEndpoint.x,
                        y: endEndpoint.y,
                    });
                }
                return handles;
            }

            // Check if a screen point is near a point handle of the selected zone/wall
            function findPointHandleAtPoint(screenX, screenY) {
                if (!selectedZone || !objects) return null;

                // Handle walls specially - they use endpoints
                if (selectedZone.type === "wall") {
                    const handles = getWallEndpointHandles(selectedZone.index);
                    for (let i = 0; i < handles.length; i++) {
                        const worldX = handles[i].x - centerX;
                        const worldY = handles[i].y - centerY;
                        const screenPos = worldToScreen(worldX, worldY);

                        const dx = screenX - screenPos.x;
                        const dy = screenY - screenPos.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < POINT_HANDLE_RADIUS + 4) {
                            return {
                                zoneType: "wall",
                                zoneIndex: selectedZone.index,
                                endpointId: handles[i].endpointId,
                            };
                        }
                    }
                    return null;
                }

                // Handle zone types
                const coords = getZoneCoords(
                    selectedZone.type,
                    selectedZone.index,
                );
                if (!coords) return null;

                for (let i = 0; i < coords.length; i++) {
                    const worldX = coords[i][0] - centerX;
                    const worldY = coords[i][1] - centerY;
                    const screenPos = worldToScreen(worldX, worldY);

                    const dx = screenX - screenPos.x;
                    const dy = screenY - screenPos.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < POINT_HANDLE_RADIUS + 4) {
                        return {
                            zoneType: selectedZone.type,
                            zoneIndex: selectedZone.index,
                            pointIndex: i,
                        };
                    }
                }

                return null;
            }

            // Draw point handles for the selected zone or wall
            function drawSelectedZoneHandles() {
                if (!selectedZone || !objects) return;

                // We need to draw in screen space so handles don't scale with zoom
                push();
                resetMatrix();

                // Handle walls - draw handles at endpoints
                if (selectedZone.type === "wall") {
                    const handles = getWallEndpointHandles(selectedZone.index);
                    for (const handle of handles) {
                        const worldX = handle.x - centerX;
                        const worldY = handle.y - centerY;
                        const screenPos = worldToScreen(worldX, worldY);

                        fill(255);
                        stroke(0);
                        strokeWeight(2);
                        ellipse(
                            screenPos.x,
                            screenPos.y,
                            POINT_HANDLE_RADIUS * 2,
                            POINT_HANDLE_RADIUS * 2,
                        );
                    }
                    pop();
                    return;
                }

                // Handle zone types
                const coords = getZoneCoords(
                    selectedZone.type,
                    selectedZone.index,
                );
                if (!coords) {
                    pop();
                    return;
                }

                for (let i = 0; i < coords.length; i++) {
                    const worldX = coords[i][0] - centerX;
                    const worldY = coords[i][1] - centerY;
                    const screenPos = worldToScreen(worldX, worldY);

                    fill(255);
                    stroke(0);
                    strokeWeight(2);
                    ellipse(
                        screenPos.x,
                        screenPos.y,
                        POINT_HANDLE_RADIUS * 2,
                        POINT_HANDLE_RADIUS * 2,
                    );
                }

                pop();
            }

            // Draw hovered point indicator or snap target
            function drawHoveredPoint() {
                // Show snap target when dragging to a point, otherwise show hovered point
                const pointToDraw = isDraggingPoint
                    ? snapTargetPoint
                    : hoveredPoint;

                // Draw all active angle/line snap indicators
                if (isDraggingPoint && activeSnaps.length > 0) {
                    drawAllSnapIndicators();
                }

                // Draw axis snap indicator (red dashed line to POI)
                if (isDraggingPoint && axisSnap) {
                    drawAxisSnapIndicator();
                }

                // Draw Point of Interest indicator (grey outlined circle)
                if (pointOfInterest) {
                    const poiWorldX = pointOfInterest.x - centerX;
                    const poiWorldY = pointOfInterest.y - centerY;
                    const poiScreenPos = worldToScreen(poiWorldX, poiWorldY);

                    push();
                    resetMatrix();
                    fill(255);
                    stroke("#9A999C");
                    strokeWeight(2);
                    ellipse(
                        poiScreenPos.x,
                        poiScreenPos.y,
                        POINT_HANDLE_RADIUS * 2,
                        POINT_HANDLE_RADIUS * 2,
                    );
                    pop();
                }

                if (!pointToDraw) return;

                // Don't show hovered point if we have a selected zone with handles
                if (!isDraggingPoint && selectedZone) return;

                const worldX = pointToDraw.x - centerX;
                const worldY = pointToDraw.y - centerY;
                const screenPos = worldToScreen(worldX, worldY);

                push();
                resetMatrix();

                fill(255);
                stroke("#9A999C");
                strokeWeight(2);
                ellipse(
                    screenPos.x,
                    screenPos.y,
                    POINT_HANDLE_RADIUS * 2,
                    POINT_HANDLE_RADIUS * 2,
                );

                // Draw red dashed circle indicator when snapping to a point
                if (isDraggingPoint && snapTargetPoint) {
                    noFill();
                    stroke("#FF0000");
                    strokeWeight(2);
                    drawingContext.setLineDash([4, 3]); // Dashed line pattern
                    const indicatorRadius = POINT_HANDLE_RADIUS + 4; // 2px gap from point edge
                    ellipse(
                        screenPos.x,
                        screenPos.y,
                        indicatorRadius * 2,
                        indicatorRadius * 2,
                    );
                    drawingContext.setLineDash([]); // Reset to solid
                }

                pop();
            }

            // Draw axis snap indicator line from current point to Point of Interest
            function drawAxisSnapIndicator() {
                if (!axisSnap || !draggedPoint) return;

                // Get current dragged point position
                let currentX, currentY;
                if (
                    draggedPoint.zoneType === "wall" &&
                    draggedPoint.endpointId
                ) {
                    const endpoint = objects.wallEndpoints?.find(
                        (e) => e.id === draggedPoint.endpointId,
                    );
                    if (!endpoint) return;
                    currentX = endpoint.x;
                    currentY = endpoint.y;
                } else {
                    const coords = getZoneCoords(
                        draggedPoint.zoneType,
                        draggedPoint.zoneIndex,
                    );
                    if (!coords || draggedPoint.pointIndex >= coords.length)
                        return;
                    currentX = coords[draggedPoint.pointIndex][0];
                    currentY = coords[draggedPoint.pointIndex][1];
                }

                const currentScreen = worldToScreen(
                    currentX - centerX,
                    currentY - centerY,
                );
                const poiScreen = worldToScreen(
                    axisSnap.poiX - centerX,
                    axisSnap.poiY - centerY,
                );

                push();
                resetMatrix();

                stroke("#FF0000");
                strokeWeight(2);
                drawingContext.setLineDash([4, 3]); // Dashed line pattern

                if (axisSnap.axis === "x" || axisSnap.axis === "both") {
                    // Draw vertical line (X axis alignment)
                    line(
                        currentScreen.x,
                        currentScreen.y,
                        currentScreen.x,
                        poiScreen.y,
                    );
                }
                if (axisSnap.axis === "y" || axisSnap.axis === "both") {
                    // Draw horizontal line (Y axis alignment)
                    line(
                        currentScreen.x,
                        currentScreen.y,
                        poiScreen.x,
                        currentScreen.y,
                    );
                }

                drawingContext.setLineDash([]); // Reset to solid
                pop();
            }

            // Draw snap indicator lines (red dashed) for colinear and perpendicular constraints
            function drawAllSnapIndicators() {
                if (activeSnaps.length === 0) return;

                push();
                resetMatrix();

                stroke("#FF0000");
                strokeWeight(2);
                strokeCap(ROUND);
                drawingContext.setLineDash([4, 3]); // Dashed line pattern

                const len = SNAP_INDICATOR_LENGTH;

                for (const snap of activeSnaps) {
                    if (!snap.snapPoint) continue;

                    const snapWorldX = snap.snapPoint.x - centerX;
                    const snapWorldY = snap.snapPoint.y - centerY;
                    const screenPos = worldToScreen(snapWorldX, snapWorldY);

                    if (snap.type === "colinear") {
                        // Draw a short red line along the snap direction
                        const dir = snap.lineDir;
                        line(
                            screenPos.x - dir.x * len,
                            screenPos.y - dir.y * len,
                            screenPos.x + dir.x * len,
                            screenPos.y + dir.y * len,
                        );
                    } else if (snap.type === "perpendicular") {
                        // Draw an "L" shape for perpendicular constraint
                        const dir1 = snap.lineDir;
                        const dir2 = snap.otherDir;

                        // Line along the new segment direction
                        line(
                            screenPos.x,
                            screenPos.y,
                            screenPos.x + dir1.x * len,
                            screenPos.y + dir1.y * len,
                        );

                        // Line along the other segment direction
                        line(
                            screenPos.x,
                            screenPos.y,
                            screenPos.x + dir2.x * len,
                            screenPos.y + dir2.y * len,
                        );
                    }
                }

                pop();
            }

            // Prevent spacebar from activating focused buttons
            document.addEventListener("keydown", function (e) {
                if (e.key === " " || e.code === "Space") {
                    e.preventDefault();
                }
            });

            // Disable context menu for right-click panning
            document.addEventListener("contextmenu", function (e) {
                e.preventDefault();
            });

            // Handle Ctrl+V / Cmd+V paste
            document.addEventListener("paste", function (e) {
                // Don't intercept if user is typing in an input field
                if (
                    e.target.tagName === "INPUT" ||
                    e.target.tagName === "TEXTAREA"
                ) {
                    return;
                }
                e.preventDefault();
                pasteFromClipboard();
            });

            // Handle Ctrl+C / Cmd+C copy
            document.addEventListener("copy", function (e) {
                // Don't intercept if user is typing in an input field
                if (
                    e.target.tagName === "INPUT" ||
                    e.target.tagName === "TEXTAREA"
                ) {
                    return;
                }
                e.preventDefault();
                copyOutput();
            });

            function keyPressed() {
                if (key === " ") {
                    spacebarDown = true;
                    spacebarStartMouseX = mouseX;
                    spacebarStartMouseY = mouseY;
                    spacebarStartPanX = panX;
                    spacebarStartPanY = panY;
                    document.body.style.cursor = "grabbing";
                }
                if (keyCode === SHIFT) {
                    shiftDown = true;
                }
            }

            function keyReleased() {
                if (key === " ") {
                    spacebarDown = false;
                    document.body.style.cursor = "default";
                }
                if (keyCode === SHIFT) {
                    shiftDown = false;
                    isZooming = false;
                }
            }

            // Touch controls for panning
            function touchStarted() {
                if (touches.length === 1) {
                    isPanning = true;
                    lastMouseX = touches[0].x;
                    lastMouseY = touches[0].y;
                }
                // Prevent default to avoid scrolling the page
                return false;
            }

            function touchMoved() {
                if (isPanning && touches.length === 1) {
                    panX += touches[0].x - lastMouseX;
                    panY += touches[0].y - lastMouseY;
                    lastMouseX = touches[0].x;
                    lastMouseY = touches[0].y;
                }
                return false;
            }

            function touchEnded() {
                isPanning = false;
                return false;
            }

            function rotateObjects(angle) {
                rotation += angle;
                markChangesPending();
            }

            function parseInput(input) {
                try {
                    objects = JSON.parse(input);

                    // Flip Y-coordinates for Hamina import
                    const canvasElem = document.getElementById("canvas");
                    const canvasHeight =
                        canvasElem && canvasElem.height
                            ? canvasElem.height
                            : canvas.height;

                    // Helper to flip Y for zone coordinates
                    function flipZoneY(zone) {
                        for (let coord of zone.area.coordinates[0]) {
                            coord[1] = canvasHeight - coord[1];
                        }
                    }

                    // Flip all zone types
                    if (objects.attenuatingZones) {
                        for (let zone of objects.attenuatingZones) {
                            flipZoneY(zone);
                        }
                    }
                    if (objects.scopeZones) {
                        for (let zone of objects.scopeZones) {
                            flipZoneY(zone);
                        }
                    }
                    if (objects.holeInFloorZones) {
                        for (let zone of objects.holeInFloorZones) {
                            flipZoneY(zone);
                        }
                    }
                    if (objects.capacityZones) {
                        for (let zone of objects.capacityZones) {
                            flipZoneY(zone);
                        }
                    }
                    if (objects.wallEndpoints) {
                        for (let endpoint of objects.wallEndpoints) {
                            endpoint.y = canvasHeight - endpoint.y;
                        }
                    }

                    // Flip Y for access points
                    if (objects.accessPoints) {
                        for (let ap of objects.accessPoints) {
                            ap.y = canvasHeight - ap.y;
                        }
                    }

                    // Flip Y for map notes
                    if (objects.mapNotes) {
                        for (let note of objects.mapNotes) {
                            note.y = canvasHeight - note.y;
                        }
                    }

                    calculateCenter();
                    rotation = 0;
                    panX = 0;
                    panY = 0;
                    return true;
                } catch (error) {
                    console.error("Error parsing input:", error);
                    showToast(
                        "There's something wrong with the clipboard data. Make sure it's from Hamina.",
                        "error",
                    );
                    return false;
                }
            }

            function calculateCenter() {
                let minX = Infinity,
                    minY = Infinity,
                    maxX = -Infinity,
                    maxY = -Infinity;

                // Helper to update bounds from zone coordinates
                function updateBoundsFromZone(zone) {
                    for (let coord of zone.area.coordinates[0]) {
                        minX = Math.min(minX, coord[0]);
                        minY = Math.min(minY, coord[1]);
                        maxX = Math.max(maxX, coord[0]);
                        maxY = Math.max(maxY, coord[1]);
                    }
                }

                // Calculate bounds from all zone types
                if (objects.attenuatingZones) {
                    for (let zone of objects.attenuatingZones) {
                        updateBoundsFromZone(zone);
                    }
                }
                if (objects.scopeZones) {
                    for (let zone of objects.scopeZones) {
                        updateBoundsFromZone(zone);
                    }
                }
                if (objects.holeInFloorZones) {
                    for (let zone of objects.holeInFloorZones) {
                        updateBoundsFromZone(zone);
                    }
                }
                if (objects.capacityZones) {
                    for (let zone of objects.capacityZones) {
                        updateBoundsFromZone(zone);
                    }
                }

                // Calculate bounds from wall endpoints
                if (objects.wallEndpoints) {
                    for (let endpoint of objects.wallEndpoints) {
                        minX = Math.min(minX, endpoint.x);
                        minY = Math.min(minY, endpoint.y);
                        maxX = Math.max(maxX, endpoint.x);
                        maxY = Math.max(maxY, endpoint.y);
                    }
                }

                // Calculate bounds from access points
                if (objects.accessPoints) {
                    for (let ap of objects.accessPoints) {
                        minX = Math.min(minX, ap.x);
                        minY = Math.min(minY, ap.y);
                        maxX = Math.max(maxX, ap.x);
                        maxY = Math.max(maxY, ap.y);
                    }
                }

                // Calculate bounds from map notes
                if (objects.mapNotes) {
                    for (let note of objects.mapNotes) {
                        minX = Math.min(minX, note.x);
                        minY = Math.min(minY, note.y);
                        maxX = Math.max(maxX, note.x);
                        maxY = Math.max(maxY, note.y);
                    }
                }

                // If no objects found, use defaults
                if (minX === Infinity) {
                    minX = maxX = centerX = 0;
                    minY = maxY = centerY = 0;
                    zoomLevel = 1;
                    return;
                }

                centerX = (minX + maxX) / 2;
                centerY = (minY + maxY) / 2;
                const objectWidth = maxX - minX;
                const objectHeight = maxY - minY;
                zoomLevel =
                    Math.min(width / objectWidth, height / objectHeight) * 0.7;
            }

            function copyOutput() {
                const rotatedObjects = getRotatedObjects();
                if (rotatedObjects) {
                    const output = JSON.stringify(rotatedObjects, null, 2);
                    navigator.clipboard.writeText(output).then(() => {
                        clearPendingChanges();
                        showToast(
                            "Canvas copied to clipboard. Go paste it into Hamina.",
                            "success",
                        );
                    });
                } else {
                    showToast(
                        "There aren't any objects on the canvas to copy to the clipboard.",
                        "error",
                    );
                }
            }

            function getRotatedObjects() {
                if (!objects) return null;

                const rotatedObjects = JSON.parse(JSON.stringify(objects));
                const canvasElem = document.getElementById("canvas");
                const canvasHeight =
                    canvasElem && canvasElem.height
                        ? canvasElem.height
                        : canvas.height;

                // Helper to rotate and flip zone coordinates
                function rotateAndFlipZone(zone) {
                    for (let coord of zone.area.coordinates[0]) {
                        const x = coord[0] - centerX;
                        const y = coord[1] - centerY;
                        const rotatedX = x * cos(rotation) - y * sin(rotation);
                        const rotatedY = x * sin(rotation) + y * cos(rotation);
                        coord[0] = rotatedX + centerX;
                        coord[1] = rotatedY + centerY;

                        // Flip Y for Hamina export
                        coord[1] = canvasHeight - coord[1];
                    }
                }

                // Rotate all zone types
                if (rotatedObjects.attenuatingZones) {
                    for (let zone of rotatedObjects.attenuatingZones) {
                        rotateAndFlipZone(zone);
                    }
                }
                if (rotatedObjects.scopeZones) {
                    for (let zone of rotatedObjects.scopeZones) {
                        rotateAndFlipZone(zone);
                    }
                }
                if (rotatedObjects.holeInFloorZones) {
                    for (let zone of rotatedObjects.holeInFloorZones) {
                        rotateAndFlipZone(zone);
                    }
                }
                if (rotatedObjects.capacityZones) {
                    for (let zone of rotatedObjects.capacityZones) {
                        rotateAndFlipZone(zone);
                    }
                }

                // Rotate wall endpoints
                if (rotatedObjects.wallEndpoints) {
                    for (let endpoint of rotatedObjects.wallEndpoints) {
                        const x = endpoint.x - centerX;
                        const y = endpoint.y - centerY;
                        const rotatedX = x * cos(rotation) - y * sin(rotation);
                        const rotatedY = x * sin(rotation) + y * cos(rotation);
                        endpoint.x = rotatedX + centerX;
                        endpoint.y = rotatedY + centerY;

                        // Flip Y for Hamina export
                        endpoint.y = canvasHeight - endpoint.y;
                    }
                }

                // Rotate access points
                if (rotatedObjects.accessPoints) {
                    for (let ap of rotatedObjects.accessPoints) {
                        const x = ap.x - centerX;
                        const y = ap.y - centerY;
                        const rotatedX = x * cos(rotation) - y * sin(rotation);
                        const rotatedY = x * sin(rotation) + y * cos(rotation);
                        ap.x = rotatedX + centerX;
                        ap.y = rotatedY + centerY;

                        // Flip Y for Hamina export
                        ap.y = canvasHeight - ap.y;
                    }
                }

                // Rotate map notes
                if (rotatedObjects.mapNotes) {
                    for (let note of rotatedObjects.mapNotes) {
                        const x = note.x - centerX;
                        const y = note.y - centerY;
                        const rotatedX = x * cos(rotation) - y * sin(rotation);
                        const rotatedY = x * sin(rotation) + y * cos(rotation);
                        note.x = rotatedX + centerX;
                        note.y = rotatedY + centerY;

                        // Flip Y for Hamina export
                        note.y = canvasHeight - note.y;
                    }
                }

                return rotatedObjects;
            }

            function clearObjects() {
                objects = null;
                jsonData = null;
                rotation = 0;
                zoomLevel = 1;
                centerX = 0;
                centerY = 0;
                // Redraw the canvas
                draw();
            }

            function convertObjectType() {
                if (!objects) {
                    showToast(
                        "There aren't any objects on the canvas. Paste some in from Hamina first.",
                        "error",
                    );
                    return;
                }

                const targetType = document.querySelector(
                    'input[name="targetType"]:checked',
                ).value;

                // Collect all polygon areas from all zone types
                const allAreas = [];

                if (objects.attenuatingZones) {
                    for (let zone of objects.attenuatingZones) {
                        allAreas.push(zone.area);
                    }
                }
                if (objects.scopeZones) {
                    for (let zone of objects.scopeZones) {
                        allAreas.push(zone.area);
                    }
                }
                if (objects.holeInFloorZones) {
                    for (let zone of objects.holeInFloorZones) {
                        allAreas.push(zone.area);
                    }
                }
                if (objects.capacityZones) {
                    for (let zone of objects.capacityZones) {
                        allAreas.push(zone.area);
                    }
                }

                if (allAreas.length === 0) {
                    showToast(
                        "There aren't any zones on the canvas to convert.",
                        "error",
                    );
                    return;
                }

                // Clear all zone arrays
                objects.attenuatingZones = [];
                objects.scopeZones = [];
                objects.holeInFloorZones = [];
                objects.capacityZones = [];

                // Convert to the target type
                switch (targetType) {
                    case "attenuatingZone":
                        // Create a default attenuating zone type if none exists
                        if (
                            !objects.attenuatingZoneTypes ||
                            objects.attenuatingZoneTypes.length === 0
                        ) {
                            objects.attenuatingZoneTypes = [
                                {
                                    id: crypto.randomUUID(),
                                    name: "Converted Zone",
                                    color: "#7AC2AF",
                                    shortcutKey: "",
                                    topEdge: 2,
                                    bottomEdge: null,
                                    attenuationDbPerMeter: 5,
                                    ituRModelEnabled: true,
                                    transparencyEnabled: false,
                                },
                            ];
                        }
                        const typeId = objects.attenuatingZoneTypes[0].id;
                        for (let area of allAreas) {
                            objects.attenuatingZones.push({
                                typeId: typeId,
                                area: area,
                            });
                        }
                        break;

                    case "scopeInclude":
                        for (let area of allAreas) {
                            objects.scopeZones.push({
                                type: "INCLUDE",
                                area: area,
                            });
                        }
                        break;

                    case "scopeExclude":
                        for (let area of allAreas) {
                            objects.scopeZones.push({
                                type: "EXCLUDE",
                                area: area,
                            });
                        }
                        break;

                    case "holeInclude":
                        for (let area of allAreas) {
                            objects.holeInFloorZones.push({
                                type: "INCLUDE",
                                area: area,
                            });
                        }
                        break;

                    case "holeExclude":
                        for (let area of allAreas) {
                            objects.holeInFloorZones.push({
                                type: "EXCLUDE",
                                area: area,
                            });
                        }
                        break;

                    case "capacityZone":
                        for (let area of allAreas) {
                            objects.capacityZones.push({
                                name: "Capacity Zone",
                                deviceAmounts: [
                                    { wifiDevice: "IPHONE", amount: 50 },
                                    { wifiDevice: "MACBOOK", amount: 50 },
                                ],
                                area: area,
                            });
                        }
                        break;
                }

                markChangesPending();
                showToast("Objects converted!", "success");
            }

            function generateCircle() {
                const circleType = document.querySelector(
                    'input[name="circleType"]:checked',
                ).value;
                const segments =
                    parseInt(document.getElementById("circleSegments").value) ||
                    32;
                const diameter =
                    parseFloat(
                        document.getElementById("circleDiameter").value,
                    ) || 10;
                const radius = diameter / 2;

                // Generate circle points centered at origin
                const points = [];
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    points.push([x, y]);
                }

                if (circleType === "wall") {
                    // Generate wall-based circle
                    const wallTypeId = crypto.randomUUID();
                    const wallEndpoints = [];
                    const walls = [];

                    // Create endpoints for each point
                    for (let i = 0; i < points.length; i++) {
                        const endpointId = crypto.randomUUID();
                        wallEndpoints.push({
                            id: endpointId,
                            x: points[i][0],
                            y: points[i][1],
                        });
                    }

                    // Create walls connecting consecutive endpoints
                    for (let i = 0; i < wallEndpoints.length; i++) {
                        const nextIndex = (i + 1) % wallEndpoints.length;
                        walls.push({
                            materialId: wallTypeId,
                            startId: wallEndpoints[i].id,
                            endId: wallEndpoints[nextIndex].id,
                        });
                    }

                    // Create the full JSON structure for walls
                    const newObjects = {
                        header: {
                            type: "HaminaClipboard",
                            version: [1, 0, 0],
                            id: crypto.randomUUID(),
                        },
                        walls: walls,
                        wallEndpoints: wallEndpoints,
                        wallTypes: [
                            {
                                id: wallTypeId,
                                name: "Drywall",
                                color: "#937E75",
                                shortcutKey: "",
                                topEdge: null,
                                bottomEdge: null,
                                width: 0.1,
                                reflectivity: 5,
                                attenuation: 3,
                                materialClass: "ITU_R_PLASTERBOARD",
                                deleted: false,
                                defaultTypeId: null,
                                transparencyEnabled: false,
                                autoFillEnabled: false,
                            },
                        ],
                        cableTrays: [],
                        cableTrayEndpoints: [],
                        attenuatingZones: [],
                        attenuatingZoneTypes: [],
                        scopeZones: [],
                        capacityZones: [],
                        holeInFloorZones: [],
                        accessPoints: [],
                        mapNotes: [],
                        tiePoints: [],
                        cableRisers: [],
                        clientDevices: [],
                        networkInfraDevices: [],
                        raisedFloorZones: [],
                        slopedFloors: [],
                    };

                    jsonData = JSON.stringify(newObjects, null, 2);
                    parseInput(jsonData);
                } else {
                    // Generate attenuating zone circle
                    const zoneTypeId = crypto.randomUUID();

                    // Close the polygon by adding the first point at the end
                    const coordinates = points.map((p) => [p[0], p[1]]);

                    const newObjects = {
                        header: {
                            type: "HaminaClipboard",
                            version: [1, 0, 0],
                            id: crypto.randomUUID(),
                        },
                        walls: [],
                        wallEndpoints: [],
                        wallTypes: [],
                        cableTrays: [],
                        cableTrayEndpoints: [],
                        attenuatingZones: [
                            {
                                typeId: zoneTypeId,
                                area: {
                                    type: "Polygon",
                                    coordinates: [coordinates],
                                },
                            },
                        ],
                        attenuatingZoneTypes: [
                            {
                                id: zoneTypeId,
                                name: "Walrus Blubber",
                                color: "#2E6CC7",
                                shortcutKey: "",
                                topEdge: 1.4,
                                bottomEdge: null,
                                attenuationDbPerMeter: 30,
                                ituRModelEnabled: true,
                                transparencyEnabled: false,
                            },
                        ],
                        scopeZones: [],
                        capacityZones: [],
                        holeInFloorZones: [],
                        accessPoints: [],
                        mapNotes: [],
                        tiePoints: [],
                        cableRisers: [],
                        clientDevices: [],
                        networkInfraDevices: [],
                        raisedFloorZones: [],
                        slopedFloors: [],
                    };

                    jsonData = JSON.stringify(newObjects, null, 2);
                    parseInput(jsonData);
                }

                markChangesPending();
                showToast("Circle generated!", "success");
            }

            function generateGrid() {
                const gridType = document.querySelector(
                    'input[name="gridType"]:checked',
                ).value;
                const rows =
                    parseInt(document.getElementById("gridRows").value) || 3;
                const columns =
                    parseInt(document.getElementById("gridColumns").value) || 3;
                const distance =
                    parseFloat(document.getElementById("gridDistance").value) ||
                    10;
                const useTriangles =
                    document.getElementById("gridTriangles").checked;

                // Calculate grid dimensions to center it
                const totalWidth = (columns - 1) * distance;
                const totalHeight = (rows - 1) * distance;
                const startX = -totalWidth / 2;
                const startY = -totalHeight / 2;

                if (gridType === "accessPoint") {
                    // Generate access points
                    const accessPoints = [];

                    for (let row = 0; row < rows; row++) {
                        // Offset odd rows by half distance for triangle pattern
                        const rowOffset =
                            useTriangles && row % 2 === 1 ? distance / 2 : 0;
                        for (let col = 0; col < columns; col++) {
                            const x = startX + col * distance + rowOffset;
                            const y = startY + row * distance;
                            const apNumber = row * columns + col + 1;

                            accessPoints.push({
                                x: x,
                                y: y,
                                make: "ciscoCatalystEnt",
                                model: "CW9166",
                                mount: "CEILING",
                                installHeight: 2.5,
                                azimuth: null,
                                elevation: null,
                                externalAntennaMake: null,
                                externalAntennaModel: null,
                                radios: [
                                    {
                                        id: crypto.randomUUID(),
                                        band: "BAND_2_4",
                                        channel: 6,
                                        txPower: 6,
                                        channelWidth: 20,
                                        enabled: false,
                                        channelLocked: false,
                                        port: null,
                                        streamCount: 4,
                                        technology: "WIFI_PROTOCOL_AX",
                                        azimuth: null,
                                        elevation: null,
                                        installHeight: null,
                                        externalAntennaMake: null,
                                        externalAntennaModel: null,
                                        mount: null,
                                    },
                                    {
                                        id: crypto.randomUUID(),
                                        band: "BAND_5",
                                        channel: 36,
                                        txPower: 10,
                                        channelWidth: 20,
                                        enabled: true,
                                        channelLocked: false,
                                        port: null,
                                        streamCount: 4,
                                        technology: "WIFI_PROTOCOL_AX",
                                        azimuth: null,
                                        elevation: null,
                                        installHeight: null,
                                        externalAntennaMake: null,
                                        externalAntennaModel: null,
                                        mount: null,
                                    },
                                    {
                                        id: crypto.randomUUID(),
                                        band: "BAND_6",
                                        channel: 1,
                                        txPower: 12,
                                        channelWidth: 20,
                                        enabled: true,
                                        channelLocked: false,
                                        port: null,
                                        streamCount: 4,
                                        technology: "WIFI_PROTOCOL_AX",
                                        azimuth: null,
                                        elevation: null,
                                        installHeight: null,
                                        externalAntennaMake: null,
                                        externalAntennaModel: null,
                                        mount: null,
                                    },
                                ],
                                primaryTechnology: "WIFI",
                                cellularRadios: [],
                                bleRadios: [
                                    {
                                        id: crypto.randomUUID(),
                                        txPowerDbm: 0,
                                    },
                                ],
                                uwbRadios: [],
                                enoceanRadios: [],
                                enoceanCapable: false,
                                zigbeeRadios: [],
                                color: "#4687f0",
                                name: "Access Point ${number}",
                                number: apNumber,
                                powerConsumption: 30.5,
                                connectedInfraDeviceId: null,
                                ethernetConnection: true,
                                perRadioOriented: false,
                                bank: 0,
                                meshUpstreamAuto: null,
                                meshUpstreamApId: null,
                                meshRadioIndex: null,
                                antennaId: "Cisco C9166",
                            });
                        }
                    }

                    const newObjects = {
                        header: {
                            type: "HaminaClipboard",
                            version: [1, 0, 0],
                            id: crypto.randomUUID(),
                        },
                        walls: [],
                        wallEndpoints: [],
                        wallTypes: [],
                        cableTrays: [],
                        cableTrayEndpoints: [],
                        attenuatingZones: [],
                        attenuatingZoneTypes: [],
                        scopeZones: [],
                        capacityZones: [],
                        holeInFloorZones: [],
                        accessPoints: accessPoints,
                        mapNotes: [],
                        tiePoints: [],
                        cableRisers: [],
                        clientDevices: [],
                        networkInfraDevices: [],
                        raisedFloorZones: [],
                        slopedFloors: [],
                    };

                    jsonData = JSON.stringify(newObjects, null, 2);
                    parseInput(jsonData);
                } else {
                    // Generate map notes
                    const mapNotes = [];

                    for (let row = 0; row < rows; row++) {
                        // Offset odd rows by half distance for triangle pattern
                        const rowOffset =
                            useTriangles && row % 2 === 1 ? distance / 2 : 0;
                        for (let col = 0; col < columns; col++) {
                            const x = startX + col * distance + rowOffset;
                            const y = startY + row * distance;

                            mapNotes.push({
                                x: x,
                                y: y,
                                text: "",
                                color: "#db6921",
                                icon: "NOTICE_OUTLINE",
                            });
                        }
                    }

                    const newObjects = {
                        header: {
                            type: "HaminaClipboard",
                            version: [1, 0, 0],
                            id: crypto.randomUUID(),
                        },
                        walls: [],
                        wallEndpoints: [],
                        wallTypes: [],
                        cableTrays: [],
                        cableTrayEndpoints: [],
                        attenuatingZones: [],
                        attenuatingZoneTypes: [],
                        scopeZones: [],
                        capacityZones: [],
                        holeInFloorZones: [],
                        accessPoints: [],
                        mapNotes: mapNotes,
                        tiePoints: [],
                        cableRisers: [],
                        clientDevices: [],
                        networkInfraDevices: [],
                        raisedFloorZones: [],
                        slopedFloors: [],
                    };

                    jsonData = JSON.stringify(newObjects, null, 2);
                    parseInput(jsonData);
                }

                markChangesPending();
                showToast("Grid generated!", "success");
            }
        </script>
    </body>
</html>
